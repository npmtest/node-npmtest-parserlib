{"/home/travis/build/npmtest/node-npmtest-parserlib/test.js":"/* istanbul instrument in package npmtest_parserlib */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-parserlib/lib.npmtest_parserlib.js":"/* istanbul instrument in package npmtest_parserlib */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_parserlib = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_parserlib = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-parserlib/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-parserlib && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_parserlib */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_parserlib\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_parserlib.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_parserlib.rollup.js'] =\n            local.assetsDict['/assets.npmtest_parserlib.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_parserlib.__dirname + '/lib.npmtest_parserlib.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-parserlib/node_modules/parserlib/src/index.js":"\"use strict\";\r\n\r\nmodule.exports = {\r\n    css  : require(\"./css\"),\r\n    util : require(\"./util\")\r\n};\r\n","/home/travis/build/npmtest/node-npmtest-parserlib/node_modules/parserlib/src/css/index.js":"\"use strict\";\r\n\r\nmodule.exports = {\r\n    Colors            : require(\"./Colors\"),\r\n    Combinator        : require(\"./Combinator\"),\r\n    Parser            : require(\"./Parser\"),\r\n    PropertyName      : require(\"./PropertyName\"),\r\n    PropertyValue     : require(\"./PropertyValue\"),\r\n    PropertyValuePart : require(\"./PropertyValuePart\"),\r\n    Matcher           : require(\"./Matcher\"),\r\n    MediaFeature      : require(\"./MediaFeature\"),\r\n    MediaQuery        : require(\"./MediaQuery\"),\r\n    Selector          : require(\"./Selector\"),\r\n    SelectorPart      : require(\"./SelectorPart\"),\r\n    SelectorSubPart   : require(\"./SelectorSubPart\"),\r\n    Specificity       : require(\"./Specificity\"),\r\n    TokenStream       : require(\"./TokenStream\"),\r\n    Tokens            : require(\"./Tokens\"),\r\n    ValidationError   : require(\"./ValidationError\")\r\n};\r\n","/home/travis/build/npmtest/node-npmtest-parserlib/node_modules/parserlib/src/css/Colors.js":"\"use strict\";\r\n\r\n/* exported Colors */\r\n\r\nvar Colors = module.exports = {\r\n    __proto__       :null,\r\n    aliceblue       :\"#f0f8ff\",\r\n    antiquewhite    :\"#faebd7\",\r\n    aqua            :\"#00ffff\",\r\n    aquamarine      :\"#7fffd4\",\r\n    azure           :\"#f0ffff\",\r\n    beige           :\"#f5f5dc\",\r\n    bisque          :\"#ffe4c4\",\r\n    black           :\"#000000\",\r\n    blanchedalmond  :\"#ffebcd\",\r\n    blue            :\"#0000ff\",\r\n    blueviolet      :\"#8a2be2\",\r\n    brown           :\"#a52a2a\",\r\n    burlywood       :\"#deb887\",\r\n    cadetblue       :\"#5f9ea0\",\r\n    chartreuse      :\"#7fff00\",\r\n    chocolate       :\"#d2691e\",\r\n    coral           :\"#ff7f50\",\r\n    cornflowerblue  :\"#6495ed\",\r\n    cornsilk        :\"#fff8dc\",\r\n    crimson         :\"#dc143c\",\r\n    cyan            :\"#00ffff\",\r\n    darkblue        :\"#00008b\",\r\n    darkcyan        :\"#008b8b\",\r\n    darkgoldenrod   :\"#b8860b\",\r\n    darkgray        :\"#a9a9a9\",\r\n    darkgrey        :\"#a9a9a9\",\r\n    darkgreen       :\"#006400\",\r\n    darkkhaki       :\"#bdb76b\",\r\n    darkmagenta     :\"#8b008b\",\r\n    darkolivegreen  :\"#556b2f\",\r\n    darkorange      :\"#ff8c00\",\r\n    darkorchid      :\"#9932cc\",\r\n    darkred         :\"#8b0000\",\r\n    darksalmon      :\"#e9967a\",\r\n    darkseagreen    :\"#8fbc8f\",\r\n    darkslateblue   :\"#483d8b\",\r\n    darkslategray   :\"#2f4f4f\",\r\n    darkslategrey   :\"#2f4f4f\",\r\n    darkturquoise   :\"#00ced1\",\r\n    darkviolet      :\"#9400d3\",\r\n    deeppink        :\"#ff1493\",\r\n    deepskyblue     :\"#00bfff\",\r\n    dimgray         :\"#696969\",\r\n    dimgrey         :\"#696969\",\r\n    dodgerblue      :\"#1e90ff\",\r\n    firebrick       :\"#b22222\",\r\n    floralwhite     :\"#fffaf0\",\r\n    forestgreen     :\"#228b22\",\r\n    fuchsia         :\"#ff00ff\",\r\n    gainsboro       :\"#dcdcdc\",\r\n    ghostwhite      :\"#f8f8ff\",\r\n    gold            :\"#ffd700\",\r\n    goldenrod       :\"#daa520\",\r\n    gray            :\"#808080\",\r\n    grey            :\"#808080\",\r\n    green           :\"#008000\",\r\n    greenyellow     :\"#adff2f\",\r\n    honeydew        :\"#f0fff0\",\r\n    hotpink         :\"#ff69b4\",\r\n    indianred       :\"#cd5c5c\",\r\n    indigo          :\"#4b0082\",\r\n    ivory           :\"#fffff0\",\r\n    khaki           :\"#f0e68c\",\r\n    lavender        :\"#e6e6fa\",\r\n    lavenderblush   :\"#fff0f5\",\r\n    lawngreen       :\"#7cfc00\",\r\n    lemonchiffon    :\"#fffacd\",\r\n    lightblue       :\"#add8e6\",\r\n    lightcoral      :\"#f08080\",\r\n    lightcyan       :\"#e0ffff\",\r\n    lightgoldenrodyellow  :\"#fafad2\",\r\n    lightgray       :\"#d3d3d3\",\r\n    lightgrey       :\"#d3d3d3\",\r\n    lightgreen      :\"#90ee90\",\r\n    lightpink       :\"#ffb6c1\",\r\n    lightsalmon     :\"#ffa07a\",\r\n    lightseagreen   :\"#20b2aa\",\r\n    lightskyblue    :\"#87cefa\",\r\n    lightslategray  :\"#778899\",\r\n    lightslategrey  :\"#778899\",\r\n    lightsteelblue  :\"#b0c4de\",\r\n    lightyellow     :\"#ffffe0\",\r\n    lime            :\"#00ff00\",\r\n    limegreen       :\"#32cd32\",\r\n    linen           :\"#faf0e6\",\r\n    magenta         :\"#ff00ff\",\r\n    maroon          :\"#800000\",\r\n    mediumaquamarine:\"#66cdaa\",\r\n    mediumblue      :\"#0000cd\",\r\n    mediumorchid    :\"#ba55d3\",\r\n    mediumpurple    :\"#9370d8\",\r\n    mediumseagreen  :\"#3cb371\",\r\n    mediumslateblue :\"#7b68ee\",\r\n    mediumspringgreen   :\"#00fa9a\",\r\n    mediumturquoise :\"#48d1cc\",\r\n    mediumvioletred :\"#c71585\",\r\n    midnightblue    :\"#191970\",\r\n    mintcream       :\"#f5fffa\",\r\n    mistyrose       :\"#ffe4e1\",\r\n    moccasin        :\"#ffe4b5\",\r\n    navajowhite     :\"#ffdead\",\r\n    navy            :\"#000080\",\r\n    oldlace         :\"#fdf5e6\",\r\n    olive           :\"#808000\",\r\n    olivedrab       :\"#6b8e23\",\r\n    orange          :\"#ffa500\",\r\n    orangered       :\"#ff4500\",\r\n    orchid          :\"#da70d6\",\r\n    palegoldenrod   :\"#eee8aa\",\r\n    palegreen       :\"#98fb98\",\r\n    paleturquoise   :\"#afeeee\",\r\n    palevioletred   :\"#d87093\",\r\n    papayawhip      :\"#ffefd5\",\r\n    peachpuff       :\"#ffdab9\",\r\n    peru            :\"#cd853f\",\r\n    pink            :\"#ffc0cb\",\r\n    plum            :\"#dda0dd\",\r\n    powderblue      :\"#b0e0e6\",\r\n    purple          :\"#800080\",\r\n    red             :\"#ff0000\",\r\n    rosybrown       :\"#bc8f8f\",\r\n    royalblue       :\"#4169e1\",\r\n    saddlebrown     :\"#8b4513\",\r\n    salmon          :\"#fa8072\",\r\n    sandybrown      :\"#f4a460\",\r\n    seagreen        :\"#2e8b57\",\r\n    seashell        :\"#fff5ee\",\r\n    sienna          :\"#a0522d\",\r\n    silver          :\"#c0c0c0\",\r\n    skyblue         :\"#87ceeb\",\r\n    slateblue       :\"#6a5acd\",\r\n    slategray       :\"#708090\",\r\n    slategrey       :\"#708090\",\r\n    snow            :\"#fffafa\",\r\n    springgreen     :\"#00ff7f\",\r\n    steelblue       :\"#4682b4\",\r\n    tan             :\"#d2b48c\",\r\n    teal            :\"#008080\",\r\n    thistle         :\"#d8bfd8\",\r\n    tomato          :\"#ff6347\",\r\n    turquoise       :\"#40e0d0\",\r\n    violet          :\"#ee82ee\",\r\n    wheat           :\"#f5deb3\",\r\n    white           :\"#ffffff\",\r\n    whitesmoke      :\"#f5f5f5\",\r\n    yellow          :\"#ffff00\",\r\n    yellowgreen     :\"#9acd32\",\r\n    //'currentColor' color keyword https://www.w3.org/TR/css3-color/#currentcolor\r\n    currentColor        :\"The value of the 'color' property.\",\r\n    //CSS2 system colors https://www.w3.org/TR/css3-color/#css2-system\r\n    activeBorder        :\"Active window border.\",\r\n    activecaption       :\"Active window caption.\",\r\n    appworkspace        :\"Background color of multiple document interface.\",\r\n    background          :\"Desktop background.\",\r\n    buttonface          :\"The face background color for 3-D elements that appear 3-D due to one layer of surrounding border.\",\r\n    buttonhighlight     :\"The color of the border facing the light source for 3-D elements that appear 3-D due to one layer of surrounding border.\",\r\n    buttonshadow        :\"The color of the border away from the light source for 3-D elements that appear 3-D due to one layer of surrounding border.\",\r\n    buttontext          :\"Text on push buttons.\",\r\n    captiontext         :\"Text in caption, size box, and scrollbar arrow box.\",\r\n    graytext            :\"Grayed (disabled) text. This color is set to #000 if the current display driver does not support a solid gray color.\",\r\n    greytext            :\"Greyed (disabled) text. This color is set to #000 if the current display driver does not support a solid grey color.\",\r\n    highlight           :\"Item(s) selected in a control.\",\r\n    highlighttext       :\"Text of item(s) selected in a control.\",\r\n    inactiveborder      :\"Inactive window border.\",\r\n    inactivecaption     :\"Inactive window caption.\",\r\n    inactivecaptiontext :\"Color of text in an inactive caption.\",\r\n    infobackground      :\"Background color for tooltip controls.\",\r\n    infotext            :\"Text color for tooltip controls.\",\r\n    menu                :\"Menu background.\",\r\n    menutext            :\"Text in menus.\",\r\n    scrollbar           :\"Scroll bar gray area.\",\r\n    threeddarkshadow    :\"The color of the darker (generally outer) of the two borders away from the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.\",\r\n    threedface          :\"The face background color for 3-D elements that appear 3-D due to two concentric layers of surrounding border.\",\r\n    threedhighlight     :\"The color of the lighter (generally outer) of the two borders facing the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.\",\r\n    threedlightshadow   :\"The color of the darker (generally inner) of the two borders facing the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.\",\r\n    threedshadow        :\"The color of the lighter (generally inner) of the two borders away from the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.\",\r\n    window              :\"Window background.\",\r\n    windowframe         :\"Window frame.\",\r\n    windowtext          :\"Text in windows.\"\r\n};\r\n","/home/travis/build/npmtest/node-npmtest-parserlib/node_modules/parserlib/src/css/Combinator.js":"\"use strict\";\r\n\r\nmodule.exports = Combinator;\r\n\r\nvar SyntaxUnit = require(\"../util/SyntaxUnit\");\r\n\r\nvar Parser = require(\"./Parser\");\r\n\r\n/**\r\n * Represents a selector combinator (whitespace, +, >).\r\n * @namespace parserlib.css\r\n * @class Combinator\r\n * @extends parserlib.util.SyntaxUnit\r\n * @constructor\r\n * @param {String} text The text representation of the unit.\r\n * @param {int} line The line of text on which the unit resides.\r\n * @param {int} col The column of text on which the unit resides.\r\n */\r\nfunction Combinator(text, line, col) {\r\n\r\n    SyntaxUnit.call(this, text, line, col, Parser.COMBINATOR_TYPE);\r\n\r\n    /**\r\n     * The type of modifier.\r\n     * @type String\r\n     * @property type\r\n     */\r\n    this.type = \"unknown\";\r\n\r\n    //pretty simple\r\n    if (/^\\s+$/.test(text)) {\r\n        this.type = \"descendant\";\r\n    } else if (text === \">\") {\r\n        this.type = \"child\";\r\n    } else if (text === \"+\") {\r\n        this.type = \"adjacent-sibling\";\r\n    } else if (text === \"~\") {\r\n        this.type = \"sibling\";\r\n    }\r\n\r\n}\r\n\r\nCombinator.prototype = new SyntaxUnit();\r\nCombinator.prototype.constructor = Combinator;\r\n\r\n","/home/travis/build/npmtest/node-npmtest-parserlib/node_modules/parserlib/src/util/SyntaxUnit.js":"\"use strict\";\r\n\r\nmodule.exports = SyntaxUnit;\r\n\r\n/**\r\n * Base type to represent a single syntactic unit.\r\n * @class SyntaxUnit\r\n * @namespace parserlib.util\r\n * @constructor\r\n * @param {String} text The text of the unit.\r\n * @param {int} line The line of text on which the unit resides.\r\n * @param {int} col The column of text on which the unit resides.\r\n */\r\nfunction SyntaxUnit(text, line, col, type) {\r\n\r\n\r\n    /**\r\n     * The column of text on which the unit resides.\r\n     * @type int\r\n     * @property col\r\n     */\r\n    this.col = col;\r\n\r\n    /**\r\n     * The line of text on which the unit resides.\r\n     * @type int\r\n     * @property line\r\n     */\r\n    this.line = line;\r\n\r\n    /**\r\n     * The text representation of the unit.\r\n     * @type String\r\n     * @property text\r\n     */\r\n    this.text = text;\r\n\r\n    /**\r\n     * The type of syntax unit.\r\n     * @type int\r\n     * @property type\r\n     */\r\n    this.type = type;\r\n}\r\n\r\n/**\r\n * Create a new syntax unit based solely on the given token.\r\n * Convenience method for creating a new syntax unit when\r\n * it represents a single token instead of multiple.\r\n * @param {Object} token The token object to represent.\r\n * @return {parserlib.util.SyntaxUnit} The object representing the token.\r\n * @static\r\n * @method fromToken\r\n */\r\nSyntaxUnit.fromToken = function(token) {\r\n    return new SyntaxUnit(token.value, token.startLine, token.startCol);\r\n};\r\n\r\nSyntaxUnit.prototype = {\r\n\r\n    //restore constructor\r\n    constructor: SyntaxUnit,\r\n\r\n    /**\r\n     * Returns the text representation of the unit.\r\n     * @return {String} The text representation of the unit.\r\n     * @method valueOf\r\n     */\r\n    valueOf: function() {\r\n        return this.toString();\r\n    },\r\n\r\n    /**\r\n     * Returns the text representation of the unit.\r\n     * @return {String} The text representation of the unit.\r\n     * @method toString\r\n     */\r\n    toString: function() {\r\n        return this.text;\r\n    }\r\n\r\n};\r\n","/home/travis/build/npmtest/node-npmtest-parserlib/node_modules/parserlib/src/css/Parser.js":"\"use strict\";\r\n\r\nmodule.exports = Parser;\r\n\r\nvar EventTarget = require(\"../util/EventTarget\");\r\nvar SyntaxError = require(\"../util/SyntaxError\");\r\nvar SyntaxUnit = require(\"../util/SyntaxUnit\");\r\n\r\nvar Combinator = require(\"./Combinator\");\r\nvar MediaFeature = require(\"./MediaFeature\");\r\nvar MediaQuery = require(\"./MediaQuery\");\r\nvar PropertyName = require(\"./PropertyName\");\r\nvar PropertyValue = require(\"./PropertyValue\");\r\nvar PropertyValuePart = require(\"./PropertyValuePart\");\r\nvar Selector = require(\"./Selector\");\r\nvar SelectorPart = require(\"./SelectorPart\");\r\nvar SelectorSubPart = require(\"./SelectorSubPart\");\r\nvar TokenStream = require(\"./TokenStream\");\r\nvar Tokens = require(\"./Tokens\");\r\nvar Validation = require(\"./Validation\");\r\n\r\n/**\r\n * A CSS3 parser.\r\n * @namespace parserlib.css\r\n * @class Parser\r\n * @constructor\r\n * @param {Object} options (Optional) Various options for the parser:\r\n *      starHack (true|false) to allow IE6 star hack as valid,\r\n *      underscoreHack (true|false) to interpret leading underscores\r\n *      as IE6-7 targeting for known properties, ieFilters (true|false)\r\n *      to indicate that IE < 8 filters should be accepted and not throw\r\n *      syntax errors.\r\n */\r\nfunction Parser(options) {\r\n\r\n    //inherit event functionality\r\n    EventTarget.call(this);\r\n\r\n\r\n    this.options = options || {};\r\n\r\n    this._tokenStream = null;\r\n}\r\n\r\n//Static constants\r\nParser.DEFAULT_TYPE = 0;\r\nParser.COMBINATOR_TYPE = 1;\r\nParser.MEDIA_FEATURE_TYPE = 2;\r\nParser.MEDIA_QUERY_TYPE = 3;\r\nParser.PROPERTY_NAME_TYPE = 4;\r\nParser.PROPERTY_VALUE_TYPE = 5;\r\nParser.PROPERTY_VALUE_PART_TYPE = 6;\r\nParser.SELECTOR_TYPE = 7;\r\nParser.SELECTOR_PART_TYPE = 8;\r\nParser.SELECTOR_SUB_PART_TYPE = 9;\r\n\r\nParser.prototype = function() {\r\n\r\n    var proto = new EventTarget(),  //new prototype\r\n        prop,\r\n        additions =  {\r\n            __proto__: null,\r\n\r\n            //restore constructor\r\n            constructor: Parser,\r\n\r\n            //instance constants - yuck\r\n            DEFAULT_TYPE : 0,\r\n            COMBINATOR_TYPE : 1,\r\n            MEDIA_FEATURE_TYPE : 2,\r\n            MEDIA_QUERY_TYPE : 3,\r\n            PROPERTY_NAME_TYPE : 4,\r\n            PROPERTY_VALUE_TYPE : 5,\r\n            PROPERTY_VALUE_PART_TYPE : 6,\r\n            SELECTOR_TYPE : 7,\r\n            SELECTOR_PART_TYPE : 8,\r\n            SELECTOR_SUB_PART_TYPE : 9,\r\n\r\n            //-----------------------------------------------------------------\r\n            // Grammar\r\n            //-----------------------------------------------------------------\r\n\r\n            _stylesheet: function() {\r\n\r\n                /*\r\n                 * stylesheet\r\n                 *  : [ CHARSET_SYM S* STRING S* ';' ]?\r\n                 *    [S|CDO|CDC]* [ import [S|CDO|CDC]* ]*\r\n                 *    [ namespace [S|CDO|CDC]* ]*\r\n                 *    [ [ ruleset | media | page | font_face | keyframes_rule | supports_rule ] [S|CDO|CDC]* ]*\r\n                 *  ;\r\n                 */\r\n\r\n                var tokenStream = this._tokenStream,\r\n                    count,\r\n                    token,\r\n                    tt;\r\n\r\n                this.fire(\"startstylesheet\");\r\n\r\n                //try to read character set\r\n                this._charset();\r\n\r\n                this._skipCruft();\r\n\r\n                //try to read imports - may be more than one\r\n                while (tokenStream.peek() === Tokens.IMPORT_SYM) {\r\n                    this._import();\r\n                    this._skipCruft();\r\n                }\r\n\r\n                //try to read namespaces - may be more than one\r\n                while (tokenStream.peek() === Tokens.NAMESPACE_SYM) {\r\n                    this._namespace();\r\n                    this._skipCruft();\r\n                }\r\n\r\n                //get the next token\r\n                tt = tokenStream.peek();\r\n\r\n                //try to read the rest\r\n                while (tt > Tokens.EOF) {\r\n\r\n                    try {\r\n\r\n                        switch (tt) {\r\n                            case Tokens.MEDIA_SYM:\r\n                                this._media();\r\n                                this._skipCruft();\r\n                                break;\r\n                            case Tokens.PAGE_SYM:\r\n                                this._page();\r\n                                this._skipCruft();\r\n                                break;\r\n                            case Tokens.FONT_FACE_SYM:\r\n                                this._font_face();\r\n                                this._skipCruft();\r\n                                break;\r\n                            case Tokens.KEYFRAMES_SYM:\r\n                                this._keyframes();\r\n                                this._skipCruft();\r\n                                break;\r\n                            case Tokens.VIEWPORT_SYM:\r\n                                this._viewport();\r\n                                this._skipCruft();\r\n                                break;\r\n                            case Tokens.DOCUMENT_SYM:\r\n                                this._document();\r\n                                this._skipCruft();\r\n                                break;\r\n                            case Tokens.SUPPORTS_SYM:\r\n                                this._supports();\r\n                                this._skipCruft();\r\n                                break;\r\n                            case Tokens.UNKNOWN_SYM:  //unknown @ rule\r\n                                tokenStream.get();\r\n                                if (!this.options.strict) {\r\n\r\n                                    //fire error event\r\n                                    this.fire({\r\n                                        type:       \"error\",\r\n                                        error:      null,\r\n                                        message:    \"Unknown @ rule: \" + tokenStream.LT(0).value + \".\",\r\n                                        line:       tokenStream.LT(0).startLine,\r\n                                        col:        tokenStream.LT(0).startCol\r\n                                    });\r\n\r\n                                    //skip braces\r\n                                    count=0;\r\n                                    while (tokenStream.advance([Tokens.LBRACE, Tokens.RBRACE]) === Tokens.LBRACE) {\r\n                                        count++;    //keep track of nesting depth\r\n                                    }\r\n\r\n                                    while (count) {\r\n                                        tokenStream.advance([Tokens.RBRACE]);\r\n                                        count--;\r\n                                    }\r\n\r\n                                } else {\r\n                                    //not a syntax error, rethrow it\r\n                                    throw new SyntaxError(\"Unknown @ rule.\", tokenStream.LT(0).startLine, tokenStream.LT(0).startCol);\r\n                                }\r\n                                break;\r\n                            case Tokens.S:\r\n                                this._readWhitespace();\r\n                                break;\r\n                            default:\r\n                                if (!this._ruleset()) {\r\n\r\n                                    //error handling for known issues\r\n                                    switch (tt) {\r\n                                        case Tokens.CHARSET_SYM:\r\n                                            token = tokenStream.LT(1);\r\n                                            this._charset(false);\r\n                                            throw new SyntaxError(\"@charset not allowed here.\", token.startLine, token.startCol);\r\n                                        case Tokens.IMPORT_SYM:\r\n                                            token = tokenStream.LT(1);\r\n                                            this._import(false);\r\n                                            throw new SyntaxError(\"@import not allowed here.\", token.startLine, token.startCol);\r\n                                        case Tokens.NAMESPACE_SYM:\r\n                                            token = tokenStream.LT(1);\r\n                                            this._namespace(false);\r\n                                            throw new SyntaxError(\"@namespace not allowed here.\", token.startLine, token.startCol);\r\n                                        default:\r\n                                            tokenStream.get();  //get the last token\r\n                                            this._unexpectedToken(tokenStream.token());\r\n                                    }\r\n\r\n                                }\r\n                        }\r\n                    } catch (ex) {\r\n                        if (ex instanceof SyntaxError && !this.options.strict) {\r\n                            this.fire({\r\n                                type:       \"error\",\r\n                                error:      ex,\r\n                                message:    ex.message,\r\n                                line:       ex.line,\r\n                                col:        ex.col\r\n                            });\r\n                        } else {\r\n                            throw ex;\r\n                        }\r\n                    }\r\n\r\n                    tt = tokenStream.peek();\r\n                }\r\n\r\n                if (tt !== Tokens.EOF) {\r\n                    this._unexpectedToken(tokenStream.token());\r\n                }\r\n\r\n                this.fire(\"endstylesheet\");\r\n            },\r\n\r\n            _charset: function(emit) {\r\n                var tokenStream = this._tokenStream,\r\n                    charset,\r\n                    token,\r\n                    line,\r\n                    col;\r\n\r\n                if (tokenStream.match(Tokens.CHARSET_SYM)) {\r\n                    line = tokenStream.token().startLine;\r\n                    col = tokenStream.token().startCol;\r\n\r\n                    this._readWhitespace();\r\n                    tokenStream.mustMatch(Tokens.STRING);\r\n\r\n                    token = tokenStream.token();\r\n                    charset = token.value;\r\n\r\n                    this._readWhitespace();\r\n                    tokenStream.mustMatch(Tokens.SEMICOLON);\r\n\r\n                    if (emit !== false) {\r\n                        this.fire({\r\n                            type:   \"charset\",\r\n                            charset:charset,\r\n                            line:   line,\r\n                            col:    col\r\n                        });\r\n                    }\r\n                }\r\n            },\r\n\r\n            _import: function(emit) {\r\n                /*\r\n                 * import\r\n                 *   : IMPORT_SYM S*\r\n                 *    [STRING|URI] S* media_query_list? ';' S*\r\n                 */\r\n\r\n                var tokenStream = this._tokenStream,\r\n                    uri,\r\n                    importToken,\r\n                    mediaList   = [];\r\n\r\n                //read import symbol\r\n                tokenStream.mustMatch(Tokens.IMPORT_SYM);\r\n                importToken = tokenStream.token();\r\n                this._readWhitespace();\r\n\r\n                tokenStream.mustMatch([Tokens.STRING, Tokens.URI]);\r\n\r\n                //grab the URI value\r\n                uri = tokenStream.token().value.replace(/^(?:url\\()?[\"']?([^\"']+?)[\"']?\\)?$/, \"$1\");\r\n\r\n                this._readWhitespace();\r\n\r\n                mediaList = this._media_query_list();\r\n\r\n                //must end with a semicolon\r\n                tokenStream.mustMatch(Tokens.SEMICOLON);\r\n                this._readWhitespace();\r\n\r\n                if (emit !== false) {\r\n                    this.fire({\r\n                        type:   \"import\",\r\n                        uri:    uri,\r\n                        media:  mediaList,\r\n                        line:   importToken.startLine,\r\n                        col:    importToken.startCol\r\n                    });\r\n                }\r\n\r\n            },\r\n\r\n            _namespace: function(emit) {\r\n                /*\r\n                 * namespace\r\n                 *   : NAMESPACE_SYM S* [namespace_prefix S*]? [STRING|URI] S* ';' S*\r\n                 */\r\n\r\n                var tokenStream = this._tokenStream,\r\n                    line,\r\n                    col,\r\n                    prefix,\r\n                    uri;\r\n\r\n                //read import symbol\r\n                tokenStream.mustMatch(Tokens.NAMESPACE_SYM);\r\n                line = tokenStream.token().startLine;\r\n                col = tokenStream.token().startCol;\r\n                this._readWhitespace();\r\n\r\n                //it's a namespace prefix - no _namespace_prefix() method because it's just an IDENT\r\n                if (tokenStream.match(Tokens.IDENT)) {\r\n                    prefix = tokenStream.token().value;\r\n                    this._readWhitespace();\r\n                }\r\n\r\n                tokenStream.mustMatch([Tokens.STRING, Tokens.URI]);\r\n                /*if (!tokenStream.match(Tokens.STRING)){\r\n                    tokenStream.mustMatch(Tokens.URI);\r\n                }*/\r\n\r\n                //grab the URI value\r\n                uri = tokenStream.token().value.replace(/(?:url\\()?[\"']([^\"']+)[\"']\\)?/, \"$1\");\r\n\r\n                this._readWhitespace();\r\n\r\n                //must end with a semicolon\r\n                tokenStream.mustMatch(Tokens.SEMICOLON);\r\n                this._readWhitespace();\r\n\r\n                if (emit !== false) {\r\n                    this.fire({\r\n                        type:   \"namespace\",\r\n                        prefix: prefix,\r\n                        uri:    uri,\r\n                        line:   line,\r\n                        col:    col\r\n                    });\r\n                }\r\n\r\n            },\r\n\r\n            _supports: function(emit) {\r\n                /*\r\n                 * supports_rule\r\n                 *  : SUPPORTS_SYM S* supports_condition S* group_rule_body\r\n                 *  ;\r\n                 */\r\n                var tokenStream = this._tokenStream,\r\n                    line,\r\n                    col;\r\n\r\n                if (tokenStream.match(Tokens.SUPPORTS_SYM)) {\r\n                    line = tokenStream.token().startLine;\r\n                    col = tokenStream.token().startCol;\r\n\r\n                    this._readWhitespace();\r\n                    this._supports_condition();\r\n                    this._readWhitespace();\r\n\r\n                    tokenStream.mustMatch(Tokens.LBRACE);\r\n                    this._readWhitespace();\r\n\r\n                    if (emit !== false) {\r\n                        this.fire({\r\n                            type:   \"startsupports\",\r\n                            line:   line,\r\n                            col:    col\r\n                        });\r\n                    }\r\n\r\n                    while (true) {\r\n                        if (!this._ruleset()) {\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    tokenStream.mustMatch(Tokens.RBRACE);\r\n                    this._readWhitespace();\r\n\r\n                    this.fire({\r\n                        type:   \"endsupports\",\r\n                        line:   line,\r\n                        col:    col\r\n                    });\r\n                }\r\n            },\r\n\r\n            _supports_condition: function() {\r\n                /*\r\n                 * supports_condition\r\n                 *  : supports_negation | supports_conjunction | supports_disjunction |\r\n                 *    supports_condition_in_parens\r\n                 *  ;\r\n                 */\r\n                var tokenStream = this._tokenStream,\r\n                    ident;\r\n\r\n                if (tokenStream.match(Tokens.IDENT)) {\r\n                    ident = tokenStream.token().value.toLowerCase();\r\n\r\n                    if (ident === \"not\") {\r\n                        tokenStream.mustMatch(Tokens.S);\r\n                        this._supports_condition_in_parens();\r\n                    } else {\r\n                        tokenStream.unget();\r\n                    }\r\n                } else {\r\n                    this._supports_condition_in_parens();\r\n                    this._readWhitespace();\r\n\r\n                    while (tokenStream.peek() === Tokens.IDENT) {\r\n                        ident = tokenStream.LT(1).value.toLowerCase();\r\n                        if (ident === \"and\" || ident === \"or\") {\r\n                            tokenStream.mustMatch(Tokens.IDENT);\r\n                            this._readWhitespace();\r\n                            this._supports_condition_in_parens();\r\n                            this._readWhitespace();\r\n                        }\r\n                    }\r\n                }\r\n            },\r\n\r\n            _supports_condition_in_parens: function() {\r\n                /*\r\n                 * supports_condition_in_parens\r\n                 *  : ( '(' S* supports_condition S* ')' ) | supports_declaration_condition |\r\n                 *    general_enclosed\r\n                 *  ;\r\n                 */\r\n                var tokenStream = this._tokenStream,\r\n                    ident;\r\n\r\n                if (tokenStream.match(Tokens.LPAREN)) {\r\n                    this._readWhitespace();\r\n                    if (tokenStream.match(Tokens.IDENT)) {\r\n                        // look ahead for not keyword, if not given, continue with declaration condition.\r\n                        ident = tokenStream.token().value.toLowerCase();\r\n                        if (ident === \"not\") {\r\n                            this._readWhitespace();\r\n                            this._supports_condition();\r\n                            this._readWhitespace();\r\n                            tokenStream.mustMatch(Tokens.RPAREN);\r\n                        } else {\r\n                            tokenStream.unget();\r\n                            this._supports_declaration_condition(false);\r\n                        }\r\n                    } else {\r\n                        this._supports_condition();\r\n                        this._readWhitespace();\r\n                        tokenStream.mustMatch(Tokens.RPAREN);\r\n                    }\r\n                } else {\r\n                    this._supports_declaration_condition();\r\n                }\r\n            },\r\n\r\n            _supports_declaration_condition: function(requireStartParen) {\r\n                /*\r\n                 * supports_declaration_condition\r\n                 *  : '(' S* declaration ')'\r\n                 *  ;\r\n                 */\r\n                var tokenStream = this._tokenStream;\r\n\r\n                if (requireStartParen !== false) {\r\n                    tokenStream.mustMatch(Tokens.LPAREN);\r\n                }\r\n                this._readWhitespace();\r\n                this._declaration();\r\n                tokenStream.mustMatch(Tokens.RPAREN);\r\n            },\r\n\r\n            _media: function() {\r\n                /*\r\n                 * media\r\n                 *   : MEDIA_SYM S* media_query_list S* '{' S* ruleset* '}' S*\r\n                 *   ;\r\n                 */\r\n                var tokenStream     = this._tokenStream,\r\n                    line,\r\n                    col,\r\n                    mediaList;//       = [];\r\n\r\n                //look for @media\r\n                tokenStream.mustMatch(Tokens.MEDIA_SYM);\r\n                line = tokenStream.token().startLine;\r\n                col = tokenStream.token().startCol;\r\n\r\n                this._readWhitespace();\r\n\r\n                mediaList = this._media_query_list();\r\n\r\n                tokenStream.mustMatch(Tokens.LBRACE);\r\n                this._readWhitespace();\r\n\r\n                this.fire({\r\n                    type:   \"startmedia\",\r\n                    media:  mediaList,\r\n                    line:   line,\r\n                    col:    col\r\n                });\r\n\r\n                while (true) {\r\n                    if (tokenStream.peek() === Tokens.PAGE_SYM) {\r\n                        this._page();\r\n                    } else if (tokenStream.peek() === Tokens.FONT_FACE_SYM) {\r\n                        this._font_face();\r\n                    } else if (tokenStream.peek() === Tokens.VIEWPORT_SYM) {\r\n                        this._viewport();\r\n                    } else if (tokenStream.peek() === Tokens.DOCUMENT_SYM) {\r\n                        this._document();\r\n                    } else if (tokenStream.peek() === Tokens.SUPPORTS_SYM) {\r\n                        this._supports();\r\n                    } else if (tokenStream.peek() === Tokens.MEDIA_SYM) {\r\n                        this._media();\r\n                    } else if (!this._ruleset()) {\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                tokenStream.mustMatch(Tokens.RBRACE);\r\n                this._readWhitespace();\r\n\r\n                this.fire({\r\n                    type:   \"endmedia\",\r\n                    media:  mediaList,\r\n                    line:   line,\r\n                    col:    col\r\n                });\r\n            },\r\n\r\n\r\n            //CSS3 Media Queries\r\n            _media_query_list: function() {\r\n                /*\r\n                 * media_query_list\r\n                 *   : S* [media_query [ ',' S* media_query ]* ]?\r\n                 *   ;\r\n                 */\r\n                var tokenStream = this._tokenStream,\r\n                    mediaList   = [];\r\n\r\n\r\n                this._readWhitespace();\r\n\r\n                if (tokenStream.peek() === Tokens.IDENT || tokenStream.peek() === Tokens.LPAREN) {\r\n                    mediaList.push(this._media_query());\r\n                }\r\n\r\n                while (tokenStream.match(Tokens.COMMA)) {\r\n                    this._readWhitespace();\r\n                    mediaList.push(this._media_query());\r\n                }\r\n\r\n                return mediaList;\r\n            },\r\n\r\n            /*\r\n             * Note: \"expression\" in the grammar maps to the _media_expression\r\n             * method.\r\n\r\n             */\r\n            _media_query: function() {\r\n                /*\r\n                 * media_query\r\n                 *   : [ONLY | NOT]? S* media_type S* [ AND S* expression ]*\r\n                 *   | expression [ AND S* expression ]*\r\n                 *   ;\r\n                 */\r\n                var tokenStream = this._tokenStream,\r\n                    type        = null,\r\n                    ident       = null,\r\n                    token       = null,\r\n                    expressions = [];\r\n\r\n                if (tokenStream.match(Tokens.IDENT)) {\r\n                    ident = tokenStream.token().value.toLowerCase();\r\n\r\n                    //since there's no custom tokens for these, need to manually check\r\n                    if (ident !== \"only\" && ident !== \"not\") {\r\n                        tokenStream.unget();\r\n                        ident = null;\r\n                    } else {\r\n                        token = tokenStream.token();\r\n                    }\r\n                }\r\n\r\n                this._readWhitespace();\r\n\r\n                if (tokenStream.peek() === Tokens.IDENT) {\r\n                    type = this._media_type();\r\n                    if (token === null) {\r\n                        token = tokenStream.token();\r\n                    }\r\n                } else if (tokenStream.peek() === Tokens.LPAREN) {\r\n                    if (token === null) {\r\n                        token = tokenStream.LT(1);\r\n                    }\r\n                    expressions.push(this._media_expression());\r\n                }\r\n\r\n                if (type === null && expressions.length === 0) {\r\n                    return null;\r\n                } else {\r\n                    this._readWhitespace();\r\n                    while (tokenStream.match(Tokens.IDENT)) {\r\n                        if (tokenStream.token().value.toLowerCase() !== \"and\") {\r\n                            this._unexpectedToken(tokenStream.token());\r\n                        }\r\n\r\n                        this._readWhitespace();\r\n                        expressions.push(this._media_expression());\r\n                    }\r\n                }\r\n\r\n                return new MediaQuery(ident, type, expressions, token.startLine, token.startCol);\r\n            },\r\n\r\n            //CSS3 Media Queries\r\n            _media_type: function() {\r\n                /*\r\n                 * media_type\r\n                 *   : IDENT\r\n                 *   ;\r\n                 */\r\n                return this._media_feature();\r\n            },\r\n\r\n            /**\r\n             * Note: in CSS3 Media Queries, this is called \"expression\".\r\n             * Renamed here to avoid conflict with CSS3 Selectors\r\n             * definition of \"expression\". Also note that \"expr\" in the\r\n             * grammar now maps to \"expression\" from CSS3 selectors.\r\n             * @method _media_expression\r\n             * @private\r\n             */\r\n            _media_expression: function() {\r\n                /*\r\n                 * expression\r\n                 *  : '(' S* media_feature S* [ ':' S* expr ]? ')' S*\r\n                 *  ;\r\n                 */\r\n                var tokenStream = this._tokenStream,\r\n                    feature     = null,\r\n                    token,\r\n                    expression  = null;\r\n\r\n                tokenStream.mustMatch(Tokens.LPAREN);\r\n\r\n                feature = this._media_feature();\r\n                this._readWhitespace();\r\n\r\n                if (tokenStream.match(Tokens.COLON)) {\r\n                    this._readWhitespace();\r\n                    token = tokenStream.LT(1);\r\n                    expression = this._expression();\r\n                }\r\n\r\n                tokenStream.mustMatch(Tokens.RPAREN);\r\n                this._readWhitespace();\r\n\r\n                return new MediaFeature(feature, expression ? new SyntaxUnit(expression, token.startLine, token.startCol) : null);\r\n            },\r\n\r\n            //CSS3 Media Queries\r\n            _media_feature: function() {\r\n                /*\r\n                 * media_feature\r\n                 *   : IDENT\r\n                 *   ;\r\n                 */\r\n                var tokenStream = this._tokenStream;\r\n\r\n                this._readWhitespace();\r\n\r\n                tokenStream.mustMatch(Tokens.IDENT);\r\n\r\n                return SyntaxUnit.fromToken(tokenStream.token());\r\n            },\r\n\r\n            //CSS3 Paged Media\r\n            _page: function() {\r\n                /*\r\n                 * page:\r\n                 *    PAGE_SYM S* IDENT? pseudo_page? S*\r\n                 *    '{' S* [ declaration | margin ]? [ ';' S* [ declaration | margin ]? ]* '}' S*\r\n                 *    ;\r\n                 */\r\n                var tokenStream = this._tokenStream,\r\n                    line,\r\n                    col,\r\n                    identifier  = null,\r\n                    pseudoPage  = null;\r\n\r\n                //look for @page\r\n                tokenStream.mustMatch(Tokens.PAGE_SYM);\r\n                line = tokenStream.token().startLine;\r\n                col = tokenStream.token().startCol;\r\n\r\n                this._readWhitespace();\r\n\r\n                if (tokenStream.match(Tokens.IDENT)) {\r\n                    identifier = tokenStream.token().value;\r\n\r\n                    //The value 'auto' may not be used as a page name and MUST be treated as a syntax error.\r\n                    if (identifier.toLowerCase() === \"auto\") {\r\n                        this._unexpectedToken(tokenStream.token());\r\n                    }\r\n                }\r\n\r\n                //see if there's a colon upcoming\r\n                if (tokenStream.peek() === Tokens.COLON) {\r\n                    pseudoPage = this._pseudo_page();\r\n                }\r\n\r\n                this._readWhitespace();\r\n\r\n                this.fire({\r\n                    type:   \"startpage\",\r\n                    id:     identifier,\r\n                    pseudo: pseudoPage,\r\n                    line:   line,\r\n                    col:    col\r\n                });\r\n\r\n                this._readDeclarations(true, true);\r\n\r\n                this.fire({\r\n                    type:   \"endpage\",\r\n                    id:     identifier,\r\n                    pseudo: pseudoPage,\r\n                    line:   line,\r\n                    col:    col\r\n                });\r\n\r\n            },\r\n\r\n            //CSS3 Paged Media\r\n            _margin: function() {\r\n                /*\r\n                 * margin :\r\n                 *    margin_sym S* '{' declaration [ ';' S* declaration? ]* '}' S*\r\n                 *    ;\r\n                 */\r\n                var tokenStream = this._tokenStream,\r\n                    line,\r\n                    col,\r\n                    marginSym   = this._margin_sym();\r\n\r\n                if (marginSym) {\r\n                    line = tokenStream.token().startLine;\r\n                    col = tokenStream.token().startCol;\r\n\r\n                    this.fire({\r\n                        type: \"startpagemargin\",\r\n                        margin: marginSym,\r\n                        line:   line,\r\n                        col:    col\r\n                    });\r\n\r\n                    this._readDeclarations(true);\r\n\r\n                    this.fire({\r\n                        type: \"endpagemargin\",\r\n                        margin: marginSym,\r\n                        line:   line,\r\n                        col:    col\r\n                    });\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            },\r\n\r\n            //CSS3 Paged Media\r\n            _margin_sym: function() {\r\n\r\n                /*\r\n                 * margin_sym :\r\n                 *    TOPLEFTCORNER_SYM |\r\n                 *    TOPLEFT_SYM |\r\n                 *    TOPCENTER_SYM |\r\n                 *    TOPRIGHT_SYM |\r\n                 *    TOPRIGHTCORNER_SYM |\r\n                 *    BOTTOMLEFTCORNER_SYM |\r\n                 *    BOTTOMLEFT_SYM |\r\n                 *    BOTTOMCENTER_SYM |\r\n                 *    BOTTOMRIGHT_SYM |\r\n                 *    BOTTOMRIGHTCORNER_SYM |\r\n                 *    LEFTTOP_SYM |\r\n                 *    LEFTMIDDLE_SYM |\r\n                 *    LEFTBOTTOM_SYM |\r\n                 *    RIGHTTOP_SYM |\r\n                 *    RIGHTMIDDLE_SYM |\r\n                 *    RIGHTBOTTOM_SYM\r\n                 *    ;\r\n                 */\r\n\r\n                var tokenStream = this._tokenStream;\r\n\r\n                if (tokenStream.match([Tokens.TOPLEFTCORNER_SYM, Tokens.TOPLEFT_SYM,\r\n                        Tokens.TOPCENTER_SYM, Tokens.TOPRIGHT_SYM, Tokens.TOPRIGHTCORNER_SYM,\r\n                        Tokens.BOTTOMLEFTCORNER_SYM, Tokens.BOTTOMLEFT_SYM,\r\n                        Tokens.BOTTOMCENTER_SYM, Tokens.BOTTOMRIGHT_SYM,\r\n                        Tokens.BOTTOMRIGHTCORNER_SYM, Tokens.LEFTTOP_SYM,\r\n                        Tokens.LEFTMIDDLE_SYM, Tokens.LEFTBOTTOM_SYM, Tokens.RIGHTTOP_SYM,\r\n                        Tokens.RIGHTMIDDLE_SYM, Tokens.RIGHTBOTTOM_SYM])) {\r\n                    return SyntaxUnit.fromToken(tokenStream.token());\r\n                } else {\r\n                    return null;\r\n                }\r\n\r\n            },\r\n\r\n            _pseudo_page: function() {\r\n                /*\r\n                 * pseudo_page\r\n                 *   : ':' IDENT\r\n                 *   ;\r\n                 */\r\n\r\n                var tokenStream = this._tokenStream;\r\n\r\n                tokenStream.mustMatch(Tokens.COLON);\r\n                tokenStream.mustMatch(Tokens.IDENT);\r\n\r\n                //TODO: CSS3 Paged Media says only \"left\", \"center\", and \"right\" are allowed\r\n\r\n                return tokenStream.token().value;\r\n            },\r\n\r\n            _font_face: function() {\r\n                /*\r\n                 * font_face\r\n                 *   : FONT_FACE_SYM S*\r\n                 *     '{' S* declaration [ ';' S* declaration ]* '}' S*\r\n                 *   ;\r\n                 */\r\n                var tokenStream = this._tokenStream,\r\n                    line,\r\n                    col;\r\n\r\n                //look for @page\r\n                tokenStream.mustMatch(Tokens.FONT_FACE_SYM);\r\n                line = tokenStream.token().startLine;\r\n                col = tokenStream.token().startCol;\r\n\r\n                this._readWhitespace();\r\n\r\n                this.fire({\r\n                    type:   \"startfontface\",\r\n                    line:   line,\r\n                    col:    col\r\n                });\r\n\r\n                this._readDeclarations(true);\r\n\r\n                this.fire({\r\n                    type:   \"endfontface\",\r\n                    line:   line,\r\n                    col:    col\r\n                });\r\n            },\r\n\r\n            _viewport: function() {\r\n                /*\r\n                 * viewport\r\n                 *   : VIEWPORT_SYM S*\r\n                 *     '{' S* declaration? [ ';' S* declaration? ]* '}' S*\r\n                 *   ;\r\n                 */\r\n                var tokenStream = this._tokenStream,\r\n                    line,\r\n                    col;\r\n\r\n                tokenStream.mustMatch(Tokens.VIEWPORT_SYM);\r\n                line = tokenStream.token().startLine;\r\n                col = tokenStream.token().startCol;\r\n\r\n                this._readWhitespace();\r\n\r\n                this.fire({\r\n                    type:   \"startviewport\",\r\n                    line:   line,\r\n                    col:    col\r\n                });\r\n\r\n                this._readDeclarations(true);\r\n\r\n                this.fire({\r\n                    type:   \"endviewport\",\r\n                    line:   line,\r\n                    col:    col\r\n                });\r\n\r\n            },\r\n\r\n            _document: function() {\r\n                /*\r\n                 * document\r\n                 *   : DOCUMENT_SYM S*\r\n                 *     _document_function [ ',' S* _document_function ]* S*\r\n                 *     '{' S* ruleset* '}'\r\n                 *   ;\r\n                 */\r\n\r\n                var tokenStream = this._tokenStream,\r\n                    token,\r\n                    functions = [],\r\n                    prefix = \"\";\r\n\r\n                tokenStream.mustMatch(Tokens.DOCUMENT_SYM);\r\n                token = tokenStream.token();\r\n                if (/^@\\-([^\\-]+)\\-/.test(token.value)) {\r\n                    prefix = RegExp.$1;\r\n                }\r\n\r\n                this._readWhitespace();\r\n                functions.push(this._document_function());\r\n\r\n                while (tokenStream.match(Tokens.COMMA)) {\r\n                    this._readWhitespace();\r\n                    functions.push(this._document_function());\r\n                }\r\n\r\n                tokenStream.mustMatch(Tokens.LBRACE);\r\n                this._readWhitespace();\r\n\r\n                this.fire({\r\n                    type:      \"startdocument\",\r\n                    functions: functions,\r\n                    prefix:    prefix,\r\n                    line:      token.startLine,\r\n                    col:       token.startCol\r\n                });\r\n\r\n                var ok = true;\r\n                while (ok) {\r\n                    switch (tokenStream.peek()) {\r\n                        case Tokens.PAGE_SYM:\r\n                            this._page();\r\n                            break;\r\n                        case Tokens.FONT_FACE_SYM:\r\n                            this._font_face();\r\n                            break;\r\n                        case Tokens.VIEWPORT_SYM:\r\n                            this._viewport();\r\n                            break;\r\n                        case Tokens.MEDIA_SYM:\r\n                            this._media();\r\n                            break;\r\n                        case Tokens.KEYFRAMES_SYM:\r\n                            this._keyframes();\r\n                            break;\r\n                        case Tokens.DOCUMENT_SYM:\r\n                            this._document();\r\n                            break;\r\n                        default:\r\n                            ok = Boolean(this._ruleset());\r\n                    }\r\n                }\r\n\r\n                tokenStream.mustMatch(Tokens.RBRACE);\r\n                token = tokenStream.token();\r\n                this._readWhitespace();\r\n\r\n                this.fire({\r\n                    type:      \"enddocument\",\r\n                    functions: functions,\r\n                    prefix:    prefix,\r\n                    line:      token.startLine,\r\n                    col:       token.startCol\r\n                });\r\n            },\r\n\r\n            _document_function: function() {\r\n                /*\r\n                 * document_function\r\n                 *   : function | URI S*\r\n                 *   ;\r\n                 */\r\n\r\n                var tokenStream = this._tokenStream,\r\n                    value;\r\n\r\n                if (tokenStream.match(Tokens.URI)) {\r\n                    value = tokenStream.token().value;\r\n                    this._readWhitespace();\r\n                } else {\r\n                    value = this._function();\r\n                }\r\n\r\n                return value;\r\n            },\r\n\r\n            _operator: function(inFunction) {\r\n\r\n                /*\r\n                 * operator (outside function)\r\n                 *  : '/' S* | ',' S* | /( empty )/\r\n                 * operator (inside function)\r\n                 *  : '/' S* | '+' S* | '*' S* | '-' S* /( empty )/\r\n                 *  ;\r\n                 */\r\n\r\n                var tokenStream = this._tokenStream,\r\n                    token       = null;\r\n\r\n                if (tokenStream.match([Tokens.SLASH, Tokens.COMMA]) ||\r\n                    (inFunction && tokenStream.match([Tokens.PLUS, Tokens.STAR, Tokens.MINUS]))) {\r\n                    token =  tokenStream.token();\r\n                    this._readWhitespace();\r\n                }\r\n                return token ? PropertyValuePart.fromToken(token) : null;\r\n\r\n            },\r\n\r\n            _combinator: function() {\r\n\r\n                /*\r\n                 * combinator\r\n                 *  : PLUS S* | GREATER S* | TILDE S* | S+\r\n                 *  ;\r\n                 */\r\n\r\n                var tokenStream = this._tokenStream,\r\n                    value       = null,\r\n                    token;\r\n\r\n                if (tokenStream.match([Tokens.PLUS, Tokens.GREATER, Tokens.TILDE])) {\r\n                    token = tokenStream.token();\r\n                    value = new Combinator(token.value, token.startLine, token.startCol);\r\n                    this._readWhitespace();\r\n                }\r\n\r\n                return value;\r\n            },\r\n\r\n            _unary_operator: function() {\r\n\r\n                /*\r\n                 * unary_operator\r\n                 *  : '-' | '+'\r\n                 *  ;\r\n                 */\r\n\r\n                var tokenStream = this._tokenStream;\r\n\r\n                if (tokenStream.match([Tokens.MINUS, Tokens.PLUS])) {\r\n                    return tokenStream.token().value;\r\n                } else {\r\n                    return null;\r\n                }\r\n            },\r\n\r\n            _property: function() {\r\n\r\n                /*\r\n                 * property\r\n                 *   : IDENT S*\r\n                 *   ;\r\n                 */\r\n\r\n                var tokenStream = this._tokenStream,\r\n                    value       = null,\r\n                    hack        = null,\r\n                    tokenValue,\r\n                    token,\r\n                    line,\r\n                    col;\r\n\r\n                //check for star hack - throws error if not allowed\r\n                if (tokenStream.peek() === Tokens.STAR && this.options.starHack) {\r\n                    tokenStream.get();\r\n                    token = tokenStream.token();\r\n                    hack = token.value;\r\n                    line = token.startLine;\r\n                    col = token.startCol;\r\n                }\r\n\r\n                if (tokenStream.match(Tokens.IDENT)) {\r\n                    token = tokenStream.token();\r\n                    tokenValue = token.value;\r\n\r\n                    //check for underscore hack - no error if not allowed because it's valid CSS syntax\r\n                    if (tokenValue.charAt(0) === \"_\" && this.options.underscoreHack) {\r\n                        hack = \"_\";\r\n                        tokenValue = tokenValue.substring(1);\r\n                    }\r\n\r\n                    value = new PropertyName(tokenValue, hack, (line||token.startLine), (col||token.startCol));\r\n                    this._readWhitespace();\r\n                }\r\n\r\n                return value;\r\n            },\r\n\r\n            //Augmented with CSS3 Selectors\r\n            _ruleset: function() {\r\n                /*\r\n                 * ruleset\r\n                 *   : selectors_group\r\n                 *     '{' S* declaration? [ ';' S* declaration? ]* '}' S*\r\n                 *   ;\r\n                 */\r\n\r\n                var tokenStream = this._tokenStream,\r\n                    tt,\r\n                    selectors;\r\n\r\n\r\n                /*\r\n                 * Error Recovery: If even a single selector fails to parse,\r\n                 * then the entire ruleset should be thrown away.\r\n                 */\r\n                try {\r\n                    selectors = this._selectors_group();\r\n                } catch (ex) {\r\n                    if (ex instanceof SyntaxError && !this.options.strict) {\r\n\r\n                        //fire error event\r\n                        this.fire({\r\n                            type:       \"error\",\r\n                            error:      ex,\r\n                            message:    ex.message,\r\n                            line:       ex.line,\r\n                            col:        ex.col\r\n                        });\r\n\r\n                        //skip over everything until closing brace\r\n                        tt = tokenStream.advance([Tokens.RBRACE]);\r\n                        if (tt === Tokens.RBRACE) {\r\n                            //if there's a right brace, the rule is finished so don't do anything\r\n                        } else {\r\n                            //otherwise, rethrow the error because it wasn't handled properly\r\n                            throw ex;\r\n                        }\r\n\r\n                    } else {\r\n                        //not a syntax error, rethrow it\r\n                        throw ex;\r\n                    }\r\n\r\n                    //trigger parser to continue\r\n                    return true;\r\n                }\r\n\r\n                //if it got here, all selectors parsed\r\n                if (selectors) {\r\n\r\n                    this.fire({\r\n                        type:       \"startrule\",\r\n                        selectors:  selectors,\r\n                        line:       selectors[0].line,\r\n                        col:        selectors[0].col\r\n                    });\r\n\r\n                    this._readDeclarations(true);\r\n\r\n                    this.fire({\r\n                        type:       \"endrule\",\r\n                        selectors:  selectors,\r\n                        line:       selectors[0].line,\r\n                        col:        selectors[0].col\r\n                    });\r\n\r\n                }\r\n\r\n                return selectors;\r\n\r\n            },\r\n\r\n            //CSS3 Selectors\r\n            _selectors_group: function() {\r\n\r\n                /*\r\n                 * selectors_group\r\n                 *   : selector [ COMMA S* selector ]*\r\n                 *   ;\r\n                 */\r\n                var tokenStream = this._tokenStream,\r\n                    selectors   = [],\r\n                    selector;\r\n\r\n                selector = this._selector();\r\n                if (selector !== null) {\r\n\r\n                    selectors.push(selector);\r\n                    while (tokenStream.match(Tokens.COMMA)) {\r\n                        this._readWhitespace();\r\n                        selector = this._selector();\r\n                        if (selector !== null) {\r\n                            selectors.push(selector);\r\n                        } else {\r\n                            this._unexpectedToken(tokenStream.LT(1));\r\n                        }\r\n                    }\r\n                }\r\n\r\n                return selectors.length ? selectors : null;\r\n            },\r\n\r\n            //CSS3 Selectors\r\n            _selector: function() {\r\n                /*\r\n                 * selector\r\n                 *   : simple_selector_sequence [ combinator simple_selector_sequence ]*\r\n                 *   ;\r\n                 */\r\n\r\n                var tokenStream = this._tokenStream,\r\n                    selector    = [],\r\n                    nextSelector = null,\r\n                    combinator  = null,\r\n                    ws          = null;\r\n\r\n                //if there's no simple selector, then there's no selector\r\n                nextSelector = this._simple_selector_sequence();\r\n                if (nextSelector === null) {\r\n                    return null;\r\n                }\r\n\r\n                selector.push(nextSelector);\r\n\r\n                do {\r\n\r\n                    //look for a combinator\r\n                    combinator = this._combinator();\r\n\r\n                    if (combinator !== null) {\r\n                        selector.push(combinator);\r\n                        nextSelector = this._simple_selector_sequence();\r\n\r\n                        //there must be a next selector\r\n                        if (nextSelector === null) {\r\n                            this._unexpectedToken(tokenStream.LT(1));\r\n                        } else {\r\n\r\n                            //nextSelector is an instance of SelectorPart\r\n                            selector.push(nextSelector);\r\n                        }\r\n                    } else {\r\n\r\n                        //if there's not whitespace, we're done\r\n                        if (this._readWhitespace()) {\r\n\r\n                            //add whitespace separator\r\n                            ws = new Combinator(tokenStream.token().value, tokenStream.token().startLine, tokenStream.token().startCol);\r\n\r\n                            //combinator is not required\r\n                            combinator = this._combinator();\r\n\r\n                            //selector is required if there's a combinator\r\n                            nextSelector = this._simple_selector_sequence();\r\n                            if (nextSelector === null) {\r\n                                if (combinator !== null) {\r\n                                    this._unexpectedToken(tokenStream.LT(1));\r\n                                }\r\n                            } else {\r\n\r\n                                if (combinator !== null) {\r\n                                    selector.push(combinator);\r\n                                } else {\r\n                                    selector.push(ws);\r\n                                }\r\n\r\n                                selector.push(nextSelector);\r\n                            }\r\n                        } else {\r\n                            break;\r\n                        }\r\n\r\n                    }\r\n                } while (true);\r\n\r\n                return new Selector(selector, selector[0].line, selector[0].col);\r\n            },\r\n\r\n            //CSS3 Selectors\r\n            _simple_selector_sequence: function() {\r\n                /*\r\n                 * simple_selector_sequence\r\n                 *   : [ type_selector | universal ]\r\n                 *     [ HASH | class | attrib | pseudo | negation ]*\r\n                 *   | [ HASH | class | attrib | pseudo | negation ]+\r\n                 *   ;\r\n                 */\r\n\r\n                var tokenStream = this._tokenStream,\r\n\r\n                    //parts of a simple selector\r\n                    elementName = null,\r\n                    modifiers   = [],\r\n\r\n                    //complete selector text\r\n                    selectorText= \"\",\r\n\r\n                    //the different parts after the element name to search for\r\n                    components  = [\r\n                        //HASH\r\n                        function() {\r\n                            return tokenStream.match(Tokens.HASH) ?\r\n                                    new SelectorSubPart(tokenStream.token().value, \"id\", tokenStream.token().startLine, tokenStream.token().startCol) :\r\n                                    null;\r\n                        },\r\n                        this._class,\r\n                        this._attrib,\r\n                        this._pseudo,\r\n                        this._negation\r\n                    ],\r\n                    i           = 0,\r\n                    len         = components.length,\r\n                    component   = null,\r\n                    line,\r\n                    col;\r\n\r\n\r\n                //get starting line and column for the selector\r\n                line = tokenStream.LT(1).startLine;\r\n                col = tokenStream.LT(1).startCol;\r\n\r\n                elementName = this._type_selector();\r\n                if (!elementName) {\r\n                    elementName = this._universal();\r\n                }\r\n\r\n                if (elementName !== null) {\r\n                    selectorText += elementName;\r\n                }\r\n\r\n                while (true) {\r\n\r\n                    //whitespace means we're done\r\n                    if (tokenStream.peek() === Tokens.S) {\r\n                        break;\r\n                    }\r\n\r\n                    //check for each component\r\n                    while (i < len && component === null) {\r\n                        component = components[i++].call(this);\r\n                    }\r\n\r\n                    if (component === null) {\r\n\r\n                        //we don't have a selector\r\n                        if (selectorText === \"\") {\r\n                            return null;\r\n                        } else {\r\n                            break;\r\n                        }\r\n                    } else {\r\n                        i = 0;\r\n                        modifiers.push(component);\r\n                        selectorText += component.toString();\r\n                        component = null;\r\n                    }\r\n                }\r\n\r\n\r\n                return selectorText !== \"\" ?\r\n                        new SelectorPart(elementName, modifiers, selectorText, line, col) :\r\n                        null;\r\n            },\r\n\r\n            //CSS3 Selectors\r\n            _type_selector: function() {\r\n                /*\r\n                 * type_selector\r\n                 *   : [ namespace_prefix ]? element_name\r\n                 *   ;\r\n                 */\r\n\r\n                var tokenStream = this._tokenStream,\r\n                    ns          = this._namespace_prefix(),\r\n                    elementName = this._element_name();\r\n\r\n                if (!elementName) {\r\n                    /*\r\n                     * Need to back out the namespace that was read due to both\r\n                     * type_selector and universal reading namespace_prefix\r\n                     * first. Kind of hacky, but only way I can figure out\r\n                     * right now how to not change the grammar.\r\n                     */\r\n                    if (ns) {\r\n                        tokenStream.unget();\r\n                        if (ns.length > 1) {\r\n                            tokenStream.unget();\r\n                        }\r\n                    }\r\n\r\n                    return null;\r\n                } else {\r\n                    if (ns) {\r\n                        elementName.text = ns + elementName.text;\r\n                        elementName.col -= ns.length;\r\n                    }\r\n                    return elementName;\r\n                }\r\n            },\r\n\r\n            //CSS3 Selectors\r\n            _class: function() {\r\n                /*\r\n                 * class\r\n                 *   : '.' IDENT\r\n                 *   ;\r\n                 */\r\n\r\n                var tokenStream = this._tokenStream,\r\n                    token;\r\n\r\n                if (tokenStream.match(Tokens.DOT)) {\r\n                    tokenStream.mustMatch(Tokens.IDENT);\r\n                    token = tokenStream.token();\r\n                    return new SelectorSubPart(\".\" + token.value, \"class\", token.startLine, token.startCol - 1);\r\n                } else {\r\n                    return null;\r\n                }\r\n\r\n            },\r\n\r\n            //CSS3 Selectors\r\n            _element_name: function() {\r\n                /*\r\n                 * element_name\r\n                 *   : IDENT\r\n                 *   ;\r\n                 */\r\n\r\n                var tokenStream = this._tokenStream,\r\n                    token;\r\n\r\n                if (tokenStream.match(Tokens.IDENT)) {\r\n                    token = tokenStream.token();\r\n                    return new SelectorSubPart(token.value, \"elementName\", token.startLine, token.startCol);\r\n\r\n                } else {\r\n                    return null;\r\n                }\r\n            },\r\n\r\n            //CSS3 Selectors\r\n            _namespace_prefix: function() {\r\n                /*\r\n                 * namespace_prefix\r\n                 *   : [ IDENT | '*' ]? '|'\r\n                 *   ;\r\n                 */\r\n                var tokenStream = this._tokenStream,\r\n                    value       = \"\";\r\n\r\n                //verify that this is a namespace prefix\r\n                if (tokenStream.LA(1) === Tokens.PIPE || tokenStream.LA(2) === Tokens.PIPE) {\r\n\r\n                    if (tokenStream.match([Tokens.IDENT, Tokens.STAR])) {\r\n                        value += tokenStream.token().value;\r\n                    }\r\n\r\n                    tokenStream.mustMatch(Tokens.PIPE);\r\n                    value += \"|\";\r\n\r\n                }\r\n\r\n                return value.length ? value : null;\r\n            },\r\n\r\n            //CSS3 Selectors\r\n            _universal: function() {\r\n                /*\r\n                 * universal\r\n                 *   : [ namespace_prefix ]? '*'\r\n                 *   ;\r\n                 */\r\n                var tokenStream = this._tokenStream,\r\n                    value       = \"\",\r\n                    ns;\r\n\r\n                ns = this._namespace_prefix();\r\n                if (ns) {\r\n                    value += ns;\r\n                }\r\n\r\n                if (tokenStream.match(Tokens.STAR)) {\r\n                    value += \"*\";\r\n                }\r\n\r\n                return value.length ? value : null;\r\n\r\n            },\r\n\r\n            //CSS3 Selectors\r\n            _attrib: function() {\r\n                /*\r\n                 * attrib\r\n                 *   : '[' S* [ namespace_prefix ]? IDENT S*\r\n                 *         [ [ PREFIXMATCH |\r\n                 *             SUFFIXMATCH |\r\n                 *             SUBSTRINGMATCH |\r\n                 *             '=' |\r\n                 *             INCLUDES |\r\n                 *             DASHMATCH ] S* [ IDENT | STRING ] S*\r\n                 *         ]? ']'\r\n                 *   ;\r\n                 */\r\n\r\n                var tokenStream = this._tokenStream,\r\n                    value       = null,\r\n                    ns,\r\n                    token;\r\n\r\n                if (tokenStream.match(Tokens.LBRACKET)) {\r\n                    token = tokenStream.token();\r\n                    value = token.value;\r\n                    value += this._readWhitespace();\r\n\r\n                    ns = this._namespace_prefix();\r\n\r\n                    if (ns) {\r\n                        value += ns;\r\n                    }\r\n\r\n                    tokenStream.mustMatch(Tokens.IDENT);\r\n                    value += tokenStream.token().value;\r\n                    value += this._readWhitespace();\r\n\r\n                    if (tokenStream.match([Tokens.PREFIXMATCH, Tokens.SUFFIXMATCH, Tokens.SUBSTRINGMATCH,\r\n                            Tokens.EQUALS, Tokens.INCLUDES, Tokens.DASHMATCH])) {\r\n\r\n                        value += tokenStream.token().value;\r\n                        value += this._readWhitespace();\r\n\r\n                        tokenStream.mustMatch([Tokens.IDENT, Tokens.STRING]);\r\n                        value += tokenStream.token().value;\r\n                        value += this._readWhitespace();\r\n                    }\r\n\r\n                    tokenStream.mustMatch(Tokens.RBRACKET);\r\n\r\n                    return new SelectorSubPart(value + \"]\", \"attribute\", token.startLine, token.startCol);\r\n                } else {\r\n                    return null;\r\n                }\r\n            },\r\n\r\n            //CSS3 Selectors\r\n            _pseudo: function() {\r\n\r\n                /*\r\n                 * pseudo\r\n                 *   : ':' ':'? [ IDENT | functional_pseudo ]\r\n                 *   ;\r\n                 */\r\n\r\n                var tokenStream = this._tokenStream,\r\n                    pseudo      = null,\r\n                    colons      = \":\",\r\n                    line,\r\n                    col;\r\n\r\n                if (tokenStream.match(Tokens.COLON)) {\r\n\r\n                    if (tokenStream.match(Tokens.COLON)) {\r\n                        colons += \":\";\r\n                    }\r\n\r\n                    if (tokenStream.match(Tokens.IDENT)) {\r\n                        pseudo = tokenStream.token().value;\r\n                        line = tokenStream.token().startLine;\r\n                        col = tokenStream.token().startCol - colons.length;\r\n                    } else if (tokenStream.peek() === Tokens.FUNCTION) {\r\n                        line = tokenStream.LT(1).startLine;\r\n                        col = tokenStream.LT(1).startCol - colons.length;\r\n                        pseudo = this._functional_pseudo();\r\n                    }\r\n\r\n                    if (pseudo) {\r\n                        pseudo = new SelectorSubPart(colons + pseudo, \"pseudo\", line, col);\r\n                    } else {\r\n                        var startLine = tokenStream.LT(1).startLine,\r\n                            startCol  = tokenStream.LT(0).startCol;\r\n                        throw new SyntaxError(\"Expected a `FUNCTION` or `IDENT` after colon at line \" + startLine + \", col \" + startCol + \".\", startLine, startCol);\r\n                    }\r\n                }\r\n\r\n                return pseudo;\r\n            },\r\n\r\n            //CSS3 Selectors\r\n            _functional_pseudo: function() {\r\n                /*\r\n                 * functional_pseudo\r\n                 *   : FUNCTION S* expression ')'\r\n                 *   ;\r\n                */\r\n\r\n                var tokenStream = this._tokenStream,\r\n                    value = null;\r\n\r\n                if (tokenStream.match(Tokens.FUNCTION)) {\r\n                    value = tokenStream.token().value;\r\n                    value += this._readWhitespace();\r\n                    value += this._expression();\r\n                    tokenStream.mustMatch(Tokens.RPAREN);\r\n                    value += \")\";\r\n                }\r\n\r\n                return value;\r\n            },\r\n\r\n            //CSS3 Selectors\r\n            _expression: function() {\r\n                /*\r\n                 * expression\r\n                 *   : [ [ PLUS | '-' | DIMENSION | NUMBER | STRING | IDENT ] S* ]+\r\n                 *   ;\r\n                 */\r\n\r\n                var tokenStream = this._tokenStream,\r\n                    value       = \"\";\r\n\r\n                while (tokenStream.match([Tokens.PLUS, Tokens.MINUS, Tokens.DIMENSION,\r\n                        Tokens.NUMBER, Tokens.STRING, Tokens.IDENT, Tokens.LENGTH,\r\n                        Tokens.FREQ, Tokens.ANGLE, Tokens.TIME,\r\n                        Tokens.RESOLUTION, Tokens.SLASH])) {\r\n\r\n                    value += tokenStream.token().value;\r\n                    value += this._readWhitespace();\r\n                }\r\n\r\n                return value.length ? value : null;\r\n\r\n            },\r\n\r\n            //CSS3 Selectors\r\n            _negation: function() {\r\n                /*\r\n                 * negation\r\n                 *   : NOT S* negation_arg S* ')'\r\n                 *   ;\r\n                 */\r\n\r\n                var tokenStream = this._tokenStream,\r\n                    line,\r\n                    col,\r\n                    value       = \"\",\r\n                    arg,\r\n                    subpart     = null;\r\n\r\n                if (tokenStream.match(Tokens.NOT)) {\r\n                    value = tokenStream.token().value;\r\n                    line = tokenStream.token().startLine;\r\n                    col = tokenStream.token().startCol;\r\n                    value += this._readWhitespace();\r\n                    arg = this._negation_arg();\r\n                    value += arg;\r\n                    value += this._readWhitespace();\r\n                    tokenStream.match(Tokens.RPAREN);\r\n                    value += tokenStream.token().value;\r\n\r\n                    subpart = new SelectorSubPart(value, \"not\", line, col);\r\n                    subpart.args.push(arg);\r\n                }\r\n\r\n                return subpart;\r\n            },\r\n\r\n            //CSS3 Selectors\r\n            _negation_arg: function() {\r\n                /*\r\n                 * negation_arg\r\n                 *   : type_selector | universal | HASH | class | attrib | pseudo\r\n                 *   ;\r\n                 */\r\n\r\n                var tokenStream = this._tokenStream,\r\n                    args        = [\r\n                        this._type_selector,\r\n                        this._universal,\r\n                        function() {\r\n                            return tokenStream.match(Tokens.HASH) ?\r\n                                    new SelectorSubPart(tokenStream.token().value, \"id\", tokenStream.token().startLine, tokenStream.token().startCol) :\r\n                                    null;\r\n                        },\r\n                        this._class,\r\n                        this._attrib,\r\n                        this._pseudo\r\n                    ],\r\n                    arg         = null,\r\n                    i           = 0,\r\n                    len         = args.length,\r\n                    line,\r\n                    col,\r\n                    part;\r\n\r\n                line = tokenStream.LT(1).startLine;\r\n                col = tokenStream.LT(1).startCol;\r\n\r\n                while (i < len && arg === null) {\r\n\r\n                    arg = args[i].call(this);\r\n                    i++;\r\n                }\r\n\r\n                //must be a negation arg\r\n                if (arg === null) {\r\n                    this._unexpectedToken(tokenStream.LT(1));\r\n                }\r\n\r\n                //it's an element name\r\n                if (arg.type === \"elementName\") {\r\n                    part = new SelectorPart(arg, [], arg.toString(), line, col);\r\n                } else {\r\n                    part = new SelectorPart(null, [arg], arg.toString(), line, col);\r\n                }\r\n\r\n                return part;\r\n            },\r\n\r\n            _declaration: function() {\r\n\r\n                /*\r\n                 * declaration\r\n                 *   : property ':' S* expr prio?\r\n                 *   | /( empty )/\r\n                 *   ;\r\n                 */\r\n\r\n                var tokenStream = this._tokenStream,\r\n                    property    = null,\r\n                    expr        = null,\r\n                    prio        = null,\r\n                    invalid     = null,\r\n                    propertyName= \"\";\r\n\r\n                property = this._property();\r\n                if (property !== null) {\r\n\r\n                    tokenStream.mustMatch(Tokens.COLON);\r\n                    this._readWhitespace();\r\n\r\n                    expr = this._expr();\r\n\r\n                    //if there's no parts for the value, it's an error\r\n                    if (!expr || expr.length === 0) {\r\n                        this._unexpectedToken(tokenStream.LT(1));\r\n                    }\r\n\r\n                    prio = this._prio();\r\n\r\n                    /*\r\n                     * If hacks should be allowed, then only check the root\r\n                     * property. If hacks should not be allowed, treat\r\n                     * _property or *property as invalid properties.\r\n                     */\r\n                    propertyName = property.toString();\r\n                    if (this.options.starHack && property.hack === \"*\" ||\r\n                            this.options.underscoreHack && property.hack === \"_\") {\r\n\r\n                        propertyName = property.text;\r\n                    }\r\n\r\n                    try {\r\n                        this._validateProperty(propertyName, expr);\r\n                    } catch (ex) {\r\n                        invalid = ex;\r\n                    }\r\n\r\n                    this.fire({\r\n                        type:       \"property\",\r\n                        property:   property,\r\n                        value:      expr,\r\n                        important:  prio,\r\n                        line:       property.line,\r\n                        col:        property.col,\r\n                        invalid:    invalid\r\n                    });\r\n\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            },\r\n\r\n            _prio: function() {\r\n                /*\r\n                 * prio\r\n                 *   : IMPORTANT_SYM S*\r\n                 *   ;\r\n                 */\r\n\r\n                var tokenStream = this._tokenStream,\r\n                    result      = tokenStream.match(Tokens.IMPORTANT_SYM);\r\n\r\n                this._readWhitespace();\r\n                return result;\r\n            },\r\n\r\n            _expr: function(inFunction) {\r\n                /*\r\n                 * expr\r\n                 *   : term [ operator term ]*\r\n                 *   ;\r\n                 */\r\n\r\n                var values      = [],\r\n                    //valueParts    = [],\r\n                    value       = null,\r\n                    operator    = null;\r\n\r\n                value = this._term(inFunction);\r\n                if (value !== null) {\r\n\r\n                    values.push(value);\r\n\r\n                    do {\r\n                        operator = this._operator(inFunction);\r\n\r\n                        //if there's an operator, keep building up the value parts\r\n                        if (operator) {\r\n                            values.push(operator);\r\n                        } /*else {\r\n                            //if there's not an operator, you have a full value\r\n                            values.push(new PropertyValue(valueParts, valueParts[0].line, valueParts[0].col));\r\n                            valueParts = [];\r\n                        }*/\r\n\r\n                        value = this._term(inFunction);\r\n\r\n                        if (value === null) {\r\n                            break;\r\n                        } else {\r\n                            values.push(value);\r\n                        }\r\n                    } while (true);\r\n                }\r\n\r\n                //cleanup\r\n                /*if (valueParts.length) {\r\n                    values.push(new PropertyValue(valueParts, valueParts[0].line, valueParts[0].col));\r\n                }*/\r\n\r\n                return values.length > 0 ? new PropertyValue(values, values[0].line, values[0].col) : null;\r\n            },\r\n\r\n            _term: function(inFunction) {\r\n\r\n                /*\r\n                 * term\r\n                 *   : unary_operator?\r\n                 *     [ NUMBER S* | PERCENTAGE S* | LENGTH S* | ANGLE S* |\r\n                 *       TIME S* | FREQ S* | function | ie_function ]\r\n                 *   | STRING S* | IDENT S* | URI S* | UNICODERANGE S* | hexcolor\r\n                 *   ;\r\n                 */\r\n\r\n                var tokenStream = this._tokenStream,\r\n                    unary       = null,\r\n                    value       = null,\r\n                    endChar     = null,\r\n                    part        = null,\r\n                    token,\r\n                    line,\r\n                    col;\r\n\r\n                //returns the operator or null\r\n                unary = this._unary_operator();\r\n                if (unary !== null) {\r\n                    line = tokenStream.token().startLine;\r\n                    col = tokenStream.token().startCol;\r\n                }\r\n\r\n                //exception for IE filters\r\n                if (tokenStream.peek() === Tokens.IE_FUNCTION && this.options.ieFilters) {\r\n\r\n                    value = this._ie_function();\r\n                    if (unary === null) {\r\n                        line = tokenStream.token().startLine;\r\n                        col = tokenStream.token().startCol;\r\n                    }\r\n\r\n                //see if it's a simple block\r\n                } else if (inFunction && tokenStream.match([Tokens.LPAREN, Tokens.LBRACE, Tokens.LBRACKET])) {\r\n\r\n                    token = tokenStream.token();\r\n                    endChar = token.endChar;\r\n                    value = token.value + this._expr(inFunction).text;\r\n                    if (unary === null) {\r\n                        line = tokenStream.token().startLine;\r\n                        col = tokenStream.token().startCol;\r\n                    }\r\n                    tokenStream.mustMatch(Tokens.type(endChar));\r\n                    value += endChar;\r\n                    this._readWhitespace();\r\n\r\n                //see if there's a simple match\r\n                } else if (tokenStream.match([Tokens.NUMBER, Tokens.PERCENTAGE, Tokens.LENGTH,\r\n                        Tokens.ANGLE, Tokens.TIME,\r\n                        Tokens.FREQ, Tokens.STRING, Tokens.IDENT, Tokens.URI, Tokens.UNICODE_RANGE])) {\r\n\r\n                    value = tokenStream.token().value;\r\n                    if (unary === null) {\r\n                        line = tokenStream.token().startLine;\r\n                        col = tokenStream.token().startCol;\r\n                        // Correct potentially-inaccurate IDENT parsing in\r\n                        // PropertyValuePart constructor.\r\n                        part = PropertyValuePart.fromToken(tokenStream.token());\r\n                    }\r\n                    this._readWhitespace();\r\n                } else {\r\n\r\n                    //see if it's a color\r\n                    token = this._hexcolor();\r\n                    if (token === null) {\r\n\r\n                        //if there's no unary, get the start of the next token for line/col info\r\n                        if (unary === null) {\r\n                            line = tokenStream.LT(1).startLine;\r\n                            col = tokenStream.LT(1).startCol;\r\n                        }\r\n\r\n                        //has to be a function\r\n                        if (value === null) {\r\n\r\n                            /*\r\n                             * This checks for alpha(opacity=0) style of IE\r\n                             * functions. IE_FUNCTION only presents progid: style.\r\n                             */\r\n                            if (tokenStream.LA(3) === Tokens.EQUALS && this.options.ieFilters) {\r\n                                value = this._ie_function();\r\n                            } else {\r\n                                value = this._function();\r\n                            }\r\n                        }\r\n\r\n                        /*if (value === null) {\r\n                            return null;\r\n                            //throw new Error(\"Expected identifier at line \" + tokenStream.token().startLine + \", character \" +  tokenStream.token().startCol + \".\");\r\n                        }*/\r\n\r\n                    } else {\r\n                        value = token.value;\r\n                        if (unary === null) {\r\n                            line = token.startLine;\r\n                            col = token.startCol;\r\n                        }\r\n                    }\r\n\r\n                }\r\n\r\n                return part !== null ? part : value !== null ?\r\n                        new PropertyValuePart(unary !== null ? unary + value : value, line, col) :\r\n                        null;\r\n\r\n            },\r\n\r\n            _function: function() {\r\n\r\n                /*\r\n                 * function\r\n                 *   : FUNCTION S* expr ')' S*\r\n                 *   ;\r\n                 */\r\n\r\n                var tokenStream = this._tokenStream,\r\n                    functionText = null,\r\n                    expr        = null,\r\n                    lt;\r\n\r\n                if (tokenStream.match(Tokens.FUNCTION)) {\r\n                    functionText = tokenStream.token().value;\r\n                    this._readWhitespace();\r\n                    expr = this._expr(true);\r\n                    functionText += expr;\r\n\r\n                    //START: Horrible hack in case it's an IE filter\r\n                    if (this.options.ieFilters && tokenStream.peek() === Tokens.EQUALS) {\r\n                        do {\r\n\r\n                            if (this._readWhitespace()) {\r\n                                functionText += tokenStream.token().value;\r\n                            }\r\n\r\n                            //might be second time in the loop\r\n                            if (tokenStream.LA(0) === Tokens.COMMA) {\r\n                                functionText += tokenStream.token().value;\r\n                            }\r\n\r\n                            tokenStream.match(Tokens.IDENT);\r\n                            functionText += tokenStream.token().value;\r\n\r\n                            tokenStream.match(Tokens.EQUALS);\r\n                            functionText += tokenStream.token().value;\r\n\r\n                            //functionText += this._term();\r\n                            lt = tokenStream.peek();\r\n                            while (lt !== Tokens.COMMA && lt !== Tokens.S && lt !== Tokens.RPAREN) {\r\n                                tokenStream.get();\r\n                                functionText += tokenStream.token().value;\r\n                                lt = tokenStream.peek();\r\n                            }\r\n                        } while (tokenStream.match([Tokens.COMMA, Tokens.S]));\r\n                    }\r\n\r\n                    //END: Horrible Hack\r\n\r\n                    tokenStream.match(Tokens.RPAREN);\r\n                    functionText += \")\";\r\n                    this._readWhitespace();\r\n                }\r\n\r\n                return functionText;\r\n            },\r\n\r\n            _ie_function: function() {\r\n\r\n                /* (My own extension)\r\n                 * ie_function\r\n                 *   : IE_FUNCTION S* IDENT '=' term [S* ','? IDENT '=' term]+ ')' S*\r\n                 *   ;\r\n                 */\r\n\r\n                var tokenStream = this._tokenStream,\r\n                    functionText = null,\r\n                    lt;\r\n\r\n                //IE function can begin like a regular function, too\r\n                if (tokenStream.match([Tokens.IE_FUNCTION, Tokens.FUNCTION])) {\r\n                    functionText = tokenStream.token().value;\r\n\r\n                    do {\r\n\r\n                        if (this._readWhitespace()) {\r\n                            functionText += tokenStream.token().value;\r\n                        }\r\n\r\n                        //might be second time in the loop\r\n                        if (tokenStream.LA(0) === Tokens.COMMA) {\r\n                            functionText += tokenStream.token().value;\r\n                        }\r\n\r\n                        tokenStream.match(Tokens.IDENT);\r\n                        functionText += tokenStream.token().value;\r\n\r\n                        tokenStream.match(Tokens.EQUALS);\r\n                        functionText += tokenStream.token().value;\r\n\r\n                        //functionText += this._term();\r\n                        lt = tokenStream.peek();\r\n                        while (lt !== Tokens.COMMA && lt !== Tokens.S && lt !== Tokens.RPAREN) {\r\n                            tokenStream.get();\r\n                            functionText += tokenStream.token().value;\r\n                            lt = tokenStream.peek();\r\n                        }\r\n                    } while (tokenStream.match([Tokens.COMMA, Tokens.S]));\r\n\r\n                    tokenStream.match(Tokens.RPAREN);\r\n                    functionText += \")\";\r\n                    this._readWhitespace();\r\n                }\r\n\r\n                return functionText;\r\n            },\r\n\r\n            _hexcolor: function() {\r\n                /*\r\n                 * There is a constraint on the color that it must\r\n                 * have either 3 or 6 hex-digits (i.e., [0-9a-fA-F])\r\n                 * after the \"#\"; e.g., \"#000\" is OK, but \"#abcd\" is not.\r\n                 *\r\n                 * hexcolor\r\n                 *   : HASH S*\r\n                 *   ;\r\n                 */\r\n\r\n                var tokenStream = this._tokenStream,\r\n                    token = null,\r\n                    color;\r\n\r\n                if (tokenStream.match(Tokens.HASH)) {\r\n\r\n                    //need to do some validation here\r\n\r\n                    token = tokenStream.token();\r\n                    color = token.value;\r\n                    if (!/#[a-f0-9]{3,6}/i.test(color)) {\r\n                        throw new SyntaxError(\"Expected a hex color but found '\" + color + \"' at line \" + token.startLine + \", col \" + token.startCol + \".\", token.startLine, token.startCol);\r\n                    }\r\n                    this._readWhitespace();\r\n                }\r\n\r\n                return token;\r\n            },\r\n\r\n            //-----------------------------------------------------------------\r\n            // Animations methods\r\n            //-----------------------------------------------------------------\r\n\r\n            _keyframes: function() {\r\n\r\n                /*\r\n                 * keyframes:\r\n                 *   : KEYFRAMES_SYM S* keyframe_name S* '{' S* keyframe_rule* '}' {\r\n                 *   ;\r\n                 */\r\n                var tokenStream = this._tokenStream,\r\n                    token,\r\n                    tt,\r\n                    name,\r\n                    prefix = \"\";\r\n\r\n                tokenStream.mustMatch(Tokens.KEYFRAMES_SYM);\r\n                token = tokenStream.token();\r\n                if (/^@\\-([^\\-]+)\\-/.test(token.value)) {\r\n                    prefix = RegExp.$1;\r\n                }\r\n\r\n                this._readWhitespace();\r\n                name = this._keyframe_name();\r\n\r\n                this._readWhitespace();\r\n                tokenStream.mustMatch(Tokens.LBRACE);\r\n\r\n                this.fire({\r\n                    type:   \"startkeyframes\",\r\n                    name:   name,\r\n                    prefix: prefix,\r\n                    line:   token.startLine,\r\n                    col:    token.startCol\r\n                });\r\n\r\n                this._readWhitespace();\r\n                tt = tokenStream.peek();\r\n\r\n                //check for key\r\n                while (tt === Tokens.IDENT || tt === Tokens.PERCENTAGE) {\r\n                    this._keyframe_rule();\r\n                    this._readWhitespace();\r\n                    tt = tokenStream.peek();\r\n                }\r\n\r\n                this.fire({\r\n                    type:   \"endkeyframes\",\r\n                    name:   name,\r\n                    prefix: prefix,\r\n                    line:   token.startLine,\r\n                    col:    token.startCol\r\n                });\r\n\r\n                this._readWhitespace();\r\n                tokenStream.mustMatch(Tokens.RBRACE);\r\n                this._readWhitespace();\r\n\r\n            },\r\n\r\n            _keyframe_name: function() {\r\n\r\n                /*\r\n                 * keyframe_name:\r\n                 *   : IDENT\r\n                 *   | STRING\r\n                 *   ;\r\n                 */\r\n                var tokenStream = this._tokenStream;\r\n\r\n                tokenStream.mustMatch([Tokens.IDENT, Tokens.STRING]);\r\n                return SyntaxUnit.fromToken(tokenStream.token());\r\n            },\r\n\r\n            _keyframe_rule: function() {\r\n\r\n                /*\r\n                 * keyframe_rule:\r\n                 *   : key_list S*\r\n                 *     '{' S* declaration [ ';' S* declaration ]* '}' S*\r\n                 *   ;\r\n                 */\r\n                var keyList = this._key_list();\r\n\r\n                this.fire({\r\n                    type:   \"startkeyframerule\",\r\n                    keys:   keyList,\r\n                    line:   keyList[0].line,\r\n                    col:    keyList[0].col\r\n                });\r\n\r\n                this._readDeclarations(true);\r\n\r\n                this.fire({\r\n                    type:   \"endkeyframerule\",\r\n                    keys:   keyList,\r\n                    line:   keyList[0].line,\r\n                    col:    keyList[0].col\r\n                });\r\n\r\n            },\r\n\r\n            _key_list: function() {\r\n\r\n                /*\r\n                 * key_list:\r\n                 *   : key [ S* ',' S* key]*\r\n                 *   ;\r\n                 */\r\n                var tokenStream = this._tokenStream,\r\n                    keyList = [];\r\n\r\n                //must be least one key\r\n                keyList.push(this._key());\r\n\r\n                this._readWhitespace();\r\n\r\n                while (tokenStream.match(Tokens.COMMA)) {\r\n                    this._readWhitespace();\r\n                    keyList.push(this._key());\r\n                    this._readWhitespace();\r\n                }\r\n\r\n                return keyList;\r\n            },\r\n\r\n            _key: function() {\r\n                /*\r\n                 * There is a restriction that IDENT can be only \"from\" or \"to\".\r\n                 *\r\n                 * key\r\n                 *   : PERCENTAGE\r\n                 *   | IDENT\r\n                 *   ;\r\n                 */\r\n\r\n                var tokenStream = this._tokenStream,\r\n                    token;\r\n\r\n                if (tokenStream.match(Tokens.PERCENTAGE)) {\r\n                    return SyntaxUnit.fromToken(tokenStream.token());\r\n                } else if (tokenStream.match(Tokens.IDENT)) {\r\n                    token = tokenStream.token();\r\n\r\n                    if (/from|to/i.test(token.value)) {\r\n                        return SyntaxUnit.fromToken(token);\r\n                    }\r\n\r\n                    tokenStream.unget();\r\n                }\r\n\r\n                //if it gets here, there wasn't a valid token, so time to explode\r\n                this._unexpectedToken(tokenStream.LT(1));\r\n            },\r\n\r\n            //-----------------------------------------------------------------\r\n            // Helper methods\r\n            //-----------------------------------------------------------------\r\n\r\n            /**\r\n             * Not part of CSS grammar, but useful for skipping over\r\n             * combination of white space and HTML-style comments.\r\n             * @return {void}\r\n             * @method _skipCruft\r\n             * @private\r\n             */\r\n            _skipCruft: function() {\r\n                while (this._tokenStream.match([Tokens.S, Tokens.CDO, Tokens.CDC])) {\r\n                    //noop\r\n                }\r\n            },\r\n\r\n            /**\r\n             * Not part of CSS grammar, but this pattern occurs frequently\r\n             * in the official CSS grammar. Split out here to eliminate\r\n             * duplicate code.\r\n             * @param {Boolean} checkStart Indicates if the rule should check\r\n             *      for the left brace at the beginning.\r\n             * @param {Boolean} readMargins Indicates if the rule should check\r\n             *      for margin patterns.\r\n             * @return {void}\r\n             * @method _readDeclarations\r\n             * @private\r\n             */\r\n            _readDeclarations: function(checkStart, readMargins) {\r\n                /*\r\n                 * Reads the pattern\r\n                 * S* '{' S* declaration [ ';' S* declaration ]* '}' S*\r\n                 * or\r\n                 * S* '{' S* [ declaration | margin ]? [ ';' S* [ declaration | margin ]? ]* '}' S*\r\n                 * Note that this is how it is described in CSS3 Paged Media, but is actually incorrect.\r\n                 * A semicolon is only necessary following a declaration if there's another declaration\r\n                 * or margin afterwards.\r\n                 */\r\n                var tokenStream = this._tokenStream,\r\n                    tt;\r\n\r\n\r\n                this._readWhitespace();\r\n\r\n                if (checkStart) {\r\n                    tokenStream.mustMatch(Tokens.LBRACE);\r\n                }\r\n\r\n                this._readWhitespace();\r\n\r\n                try {\r\n\r\n                    while (true) {\r\n\r\n                        if (tokenStream.match(Tokens.SEMICOLON) || (readMargins && this._margin())) {\r\n                            //noop\r\n                        } else if (this._declaration()) {\r\n                            if (!tokenStream.match(Tokens.SEMICOLON)) {\r\n                                break;\r\n                            }\r\n                        } else {\r\n                            break;\r\n                        }\r\n\r\n                        //if ((!this._margin() && !this._declaration()) || !tokenStream.match(Tokens.SEMICOLON)){\r\n                        //    break;\r\n                        //}\r\n                        this._readWhitespace();\r\n                    }\r\n\r\n                    tokenStream.mustMatch(Tokens.RBRACE);\r\n                    this._readWhitespace();\r\n\r\n                } catch (ex) {\r\n                    if (ex instanceof SyntaxError && !this.options.strict) {\r\n\r\n                        //fire error event\r\n                        this.fire({\r\n                            type:       \"error\",\r\n                            error:      ex,\r\n                            message:    ex.message,\r\n                            line:       ex.line,\r\n                            col:        ex.col\r\n                        });\r\n\r\n                        //see if there's another declaration\r\n                        tt = tokenStream.advance([Tokens.SEMICOLON, Tokens.RBRACE]);\r\n                        if (tt === Tokens.SEMICOLON) {\r\n                            //if there's a semicolon, then there might be another declaration\r\n                            this._readDeclarations(false, readMargins);\r\n                        } else if (tt !== Tokens.RBRACE) {\r\n                            //if there's a right brace, the rule is finished so don't do anything\r\n                            //otherwise, rethrow the error because it wasn't handled properly\r\n                            throw ex;\r\n                        }\r\n\r\n                    } else {\r\n                        //not a syntax error, rethrow it\r\n                        throw ex;\r\n                    }\r\n                }\r\n\r\n            },\r\n\r\n            /**\r\n             * In some cases, you can end up with two white space tokens in a\r\n             * row. Instead of making a change in every function that looks for\r\n             * white space, this function is used to match as much white space\r\n             * as necessary.\r\n             * @method _readWhitespace\r\n             * @return {String} The white space if found, empty string if not.\r\n             * @private\r\n             */\r\n            _readWhitespace: function() {\r\n\r\n                var tokenStream = this._tokenStream,\r\n                    ws = \"\";\r\n\r\n                while (tokenStream.match(Tokens.S)) {\r\n                    ws += tokenStream.token().value;\r\n                }\r\n\r\n                return ws;\r\n            },\r\n\r\n\r\n            /**\r\n             * Throws an error when an unexpected token is found.\r\n             * @param {Object} token The token that was found.\r\n             * @method _unexpectedToken\r\n             * @return {void}\r\n             * @private\r\n             */\r\n            _unexpectedToken: function(token) {\r\n                throw new SyntaxError(\"Unexpected token '\" + token.value + \"' at line \" + token.startLine + \", col \" + token.startCol + \".\", token.startLine, token.startCol);\r\n            },\r\n\r\n            /**\r\n             * Helper method used for parsing subparts of a style sheet.\r\n             * @return {void}\r\n             * @method _verifyEnd\r\n             * @private\r\n             */\r\n            _verifyEnd: function() {\r\n                if (this._tokenStream.LA(1) !== Tokens.EOF) {\r\n                    this._unexpectedToken(this._tokenStream.LT(1));\r\n                }\r\n            },\r\n\r\n            //-----------------------------------------------------------------\r\n            // Validation methods\r\n            //-----------------------------------------------------------------\r\n            _validateProperty: function(property, value) {\r\n                Validation.validate(property, value);\r\n            },\r\n\r\n            //-----------------------------------------------------------------\r\n            // Parsing methods\r\n            //-----------------------------------------------------------------\r\n\r\n            parse: function(input) {\r\n                this._tokenStream = new TokenStream(input, Tokens);\r\n                this._stylesheet();\r\n            },\r\n\r\n            parseStyleSheet: function(input) {\r\n                //just passthrough\r\n                return this.parse(input);\r\n            },\r\n\r\n            parseMediaQuery: function(input) {\r\n                this._tokenStream = new TokenStream(input, Tokens);\r\n                var result = this._media_query();\r\n\r\n                //if there's anything more, then it's an invalid selector\r\n                this._verifyEnd();\r\n\r\n                //otherwise return result\r\n                return result;\r\n            },\r\n\r\n            /**\r\n             * Parses a property value (everything after the semicolon).\r\n             * @return {parserlib.css.PropertyValue} The property value.\r\n             * @throws parserlib.util.SyntaxError If an unexpected token is found.\r\n             * @method parserPropertyValue\r\n             */\r\n            parsePropertyValue: function(input) {\r\n\r\n                this._tokenStream = new TokenStream(input, Tokens);\r\n                this._readWhitespace();\r\n\r\n                var result = this._expr();\r\n\r\n                //okay to have a trailing white space\r\n                this._readWhitespace();\r\n\r\n                //if there's anything more, then it's an invalid selector\r\n                this._verifyEnd();\r\n\r\n                //otherwise return result\r\n                return result;\r\n            },\r\n\r\n            /**\r\n             * Parses a complete CSS rule, including selectors and\r\n             * properties.\r\n             * @param {String} input The text to parser.\r\n             * @return {Boolean} True if the parse completed successfully, false if not.\r\n             * @method parseRule\r\n             */\r\n            parseRule: function(input) {\r\n                this._tokenStream = new TokenStream(input, Tokens);\r\n\r\n                //skip any leading white space\r\n                this._readWhitespace();\r\n\r\n                var result = this._ruleset();\r\n\r\n                //skip any trailing white space\r\n                this._readWhitespace();\r\n\r\n                //if there's anything more, then it's an invalid selector\r\n                this._verifyEnd();\r\n\r\n                //otherwise return result\r\n                return result;\r\n            },\r\n\r\n            /**\r\n             * Parses a single CSS selector (no comma)\r\n             * @param {String} input The text to parse as a CSS selector.\r\n             * @return {Selector} An object representing the selector.\r\n             * @throws parserlib.util.SyntaxError If an unexpected token is found.\r\n             * @method parseSelector\r\n             */\r\n            parseSelector: function(input) {\r\n\r\n                this._tokenStream = new TokenStream(input, Tokens);\r\n\r\n                //skip any leading white space\r\n                this._readWhitespace();\r\n\r\n                var result = this._selector();\r\n\r\n                //skip any trailing white space\r\n                this._readWhitespace();\r\n\r\n                //if there's anything more, then it's an invalid selector\r\n                this._verifyEnd();\r\n\r\n                //otherwise return result\r\n                return result;\r\n            },\r\n\r\n            /**\r\n             * Parses an HTML style attribute: a set of CSS declarations\r\n             * separated by semicolons.\r\n             * @param {String} input The text to parse as a style attribute\r\n             * @return {void}\r\n             * @method parseStyleAttribute\r\n             */\r\n            parseStyleAttribute: function(input) {\r\n                input += \"}\"; // for error recovery in _readDeclarations()\r\n                this._tokenStream = new TokenStream(input, Tokens);\r\n                this._readDeclarations();\r\n            }\r\n        };\r\n\r\n    //copy over onto prototype\r\n    for (prop in additions) {\r\n        if (Object.prototype.hasOwnProperty.call(additions, prop)) {\r\n            proto[prop] = additions[prop];\r\n        }\r\n    }\r\n\r\n    return proto;\r\n}();\r\n\r\n\r\n/*\r\nnth\r\n  : S* [ ['-'|'+']? INTEGER? {N} [ S* ['-'|'+'] S* INTEGER ]? |\r\n         ['-'|'+']? INTEGER | {O}{D}{D} | {E}{V}{E}{N} ] S*\r\n  ;\r\n*/\r\n","/home/travis/build/npmtest/node-npmtest-parserlib/node_modules/parserlib/src/util/EventTarget.js":"\"use strict\";\r\n\r\nmodule.exports = EventTarget;\r\n\r\n/**\r\n * A generic base to inherit from for any object\r\n * that needs event handling.\r\n * @class EventTarget\r\n * @constructor\r\n */\r\nfunction EventTarget() {\r\n\r\n    /**\r\n     * The array of listeners for various events.\r\n     * @type Object\r\n     * @property _listeners\r\n     * @private\r\n     */\r\n    this._listeners = Object.create(null);\r\n}\r\n\r\nEventTarget.prototype = {\r\n\r\n    //restore constructor\r\n    constructor: EventTarget,\r\n\r\n    /**\r\n     * Adds a listener for a given event type.\r\n     * @param {String} type The type of event to add a listener for.\r\n     * @param {Function} listener The function to call when the event occurs.\r\n     * @return {void}\r\n     * @method addListener\r\n     */\r\n    addListener: function(type, listener) {\r\n        if (!this._listeners[type]) {\r\n            this._listeners[type] = [];\r\n        }\r\n\r\n        this._listeners[type].push(listener);\r\n    },\r\n\r\n    /**\r\n     * Fires an event based on the passed-in object.\r\n     * @param {Object|String} event An object with at least a 'type' attribute\r\n     *      or a string indicating the event name.\r\n     * @return {void}\r\n     * @method fire\r\n     */\r\n    fire: function(event) {\r\n        if (typeof event === \"string\") {\r\n            event = { type: event };\r\n        }\r\n        if (typeof event.target !== \"undefined\") {\r\n            event.target = this;\r\n        }\r\n\r\n        if (typeof event.type === \"undefined\") {\r\n            throw new Error(\"Event object missing 'type' property.\");\r\n        }\r\n\r\n        if (this._listeners[event.type]) {\r\n\r\n            //create a copy of the array and use that so listeners can't chane\r\n            var listeners = this._listeners[event.type].concat();\r\n            for (var i=0, len=listeners.length; i < len; i++) {\r\n                listeners[i].call(this, event);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Removes a listener for a given event type.\r\n     * @param {String} type The type of event to remove a listener from.\r\n     * @param {Function} listener The function to remove from the event.\r\n     * @return {void}\r\n     * @method removeListener\r\n     */\r\n    removeListener: function(type, listener) {\r\n        if (this._listeners[type]) {\r\n            var listeners = this._listeners[type];\r\n            for (var i=0, len=listeners.length; i < len; i++) {\r\n                if (listeners[i] === listener) {\r\n                    listeners.splice(i, 1);\r\n                    break;\r\n                }\r\n            }\r\n\r\n\r\n        }\r\n    }\r\n};\r\n","/home/travis/build/npmtest/node-npmtest-parserlib/node_modules/parserlib/src/util/SyntaxError.js":"\"use strict\";\r\n\r\nmodule.exports = SyntaxError;\r\n\r\n/**\r\n * Type to use when a syntax error occurs.\r\n * @class SyntaxError\r\n * @namespace parserlib.util\r\n * @constructor\r\n * @param {String} message The error message.\r\n * @param {int} line The line at which the error occurred.\r\n * @param {int} col The column at which the error occurred.\r\n */\r\nfunction SyntaxError(message, line, col) {\r\n    Error.call(this);\r\n    this.name = this.constructor.name;\r\n\r\n    /**\r\n     * The column at which the error occurred.\r\n     * @type int\r\n     * @property col\r\n     */\r\n    this.col = col;\r\n\r\n    /**\r\n     * The line at which the error occurred.\r\n     * @type int\r\n     * @property line\r\n     */\r\n    this.line = line;\r\n\r\n    /**\r\n     * The text representation of the unit.\r\n     * @type String\r\n     * @property text\r\n     */\r\n    this.message = message;\r\n\r\n}\r\n\r\n//inherit from Error\r\nSyntaxError.prototype = Object.create(Error.prototype); // jshint ignore:line\r\nSyntaxError.prototype.constructor = SyntaxError; // jshint ignore:line\r\n","/home/travis/build/npmtest/node-npmtest-parserlib/node_modules/parserlib/src/css/MediaFeature.js":"\"use strict\";\r\n\r\nmodule.exports = MediaFeature;\r\n\r\nvar SyntaxUnit = require(\"../util/SyntaxUnit\");\r\n\r\nvar Parser = require(\"./Parser\");\r\n\r\n/**\r\n * Represents a media feature, such as max-width:500.\r\n * @namespace parserlib.css\r\n * @class MediaFeature\r\n * @extends parserlib.util.SyntaxUnit\r\n * @constructor\r\n * @param {SyntaxUnit} name The name of the feature.\r\n * @param {SyntaxUnit} value The value of the feature or null if none.\r\n */\r\nfunction MediaFeature(name, value) {\r\n\r\n    SyntaxUnit.call(this, \"(\" + name + (value !== null ? \":\" + value : \"\") + \")\", name.startLine, name.startCol, Parser.MEDIA_FEATURE_TYPE);\r\n\r\n    /**\r\n     * The name of the media feature\r\n     * @type String\r\n     * @property name\r\n     */\r\n    this.name = name;\r\n\r\n    /**\r\n     * The value for the feature or null if there is none.\r\n     * @type SyntaxUnit\r\n     * @property value\r\n     */\r\n    this.value = value;\r\n}\r\n\r\nMediaFeature.prototype = new SyntaxUnit();\r\nMediaFeature.prototype.constructor = MediaFeature;\r\n\r\n","/home/travis/build/npmtest/node-npmtest-parserlib/node_modules/parserlib/src/css/MediaQuery.js":"\"use strict\";\r\n\r\nmodule.exports = MediaQuery;\r\n\r\nvar SyntaxUnit = require(\"../util/SyntaxUnit\");\r\n\r\nvar Parser = require(\"./Parser\");\r\n\r\n/**\r\n * Represents an individual media query.\r\n * @namespace parserlib.css\r\n * @class MediaQuery\r\n * @extends parserlib.util.SyntaxUnit\r\n * @constructor\r\n * @param {String} modifier The modifier \"not\" or \"only\" (or null).\r\n * @param {String} mediaType The type of media (i.e., \"print\").\r\n * @param {Array} parts Array of selectors parts making up this selector.\r\n * @param {int} line The line of text on which the unit resides.\r\n * @param {int} col The column of text on which the unit resides.\r\n */\r\nfunction MediaQuery(modifier, mediaType, features, line, col) {\r\n\r\n    SyntaxUnit.call(this, (modifier ? modifier + \" \": \"\") + (mediaType ? mediaType : \"\") + (mediaType && features.length > 0 ? \" and \" : \"\") + features.join(\" and \"), line, col, Parser.MEDIA_QUERY_TYPE);\r\n\r\n    /**\r\n     * The media modifier (\"not\" or \"only\")\r\n     * @type String\r\n     * @property modifier\r\n     */\r\n    this.modifier = modifier;\r\n\r\n    /**\r\n     * The mediaType (i.e., \"print\")\r\n     * @type String\r\n     * @property mediaType\r\n     */\r\n    this.mediaType = mediaType;\r\n\r\n    /**\r\n     * The parts that make up the selector.\r\n     * @type Array\r\n     * @property features\r\n     */\r\n    this.features = features;\r\n\r\n}\r\n\r\nMediaQuery.prototype = new SyntaxUnit();\r\nMediaQuery.prototype.constructor = MediaQuery;\r\n\r\n","/home/travis/build/npmtest/node-npmtest-parserlib/node_modules/parserlib/src/css/PropertyName.js":"\"use strict\";\r\n\r\nmodule.exports = PropertyName;\r\n\r\nvar SyntaxUnit = require(\"../util/SyntaxUnit\");\r\n\r\nvar Parser = require(\"./Parser\");\r\n\r\n/**\r\n * Represents a selector combinator (whitespace, +, >).\r\n * @namespace parserlib.css\r\n * @class PropertyName\r\n * @extends parserlib.util.SyntaxUnit\r\n * @constructor\r\n * @param {String} text The text representation of the unit.\r\n * @param {String} hack The type of IE hack applied (\"*\", \"_\", or null).\r\n * @param {int} line The line of text on which the unit resides.\r\n * @param {int} col The column of text on which the unit resides.\r\n */\r\nfunction PropertyName(text, hack, line, col) {\r\n\r\n    SyntaxUnit.call(this, text, line, col, Parser.PROPERTY_NAME_TYPE);\r\n\r\n    /**\r\n     * The type of IE hack applied (\"*\", \"_\", or null).\r\n     * @type String\r\n     * @property hack\r\n     */\r\n    this.hack = hack;\r\n\r\n}\r\n\r\nPropertyName.prototype = new SyntaxUnit();\r\nPropertyName.prototype.constructor = PropertyName;\r\nPropertyName.prototype.toString = function() {\r\n    return (this.hack ? this.hack : \"\") + this.text;\r\n};\r\n","/home/travis/build/npmtest/node-npmtest-parserlib/node_modules/parserlib/src/css/PropertyValue.js":"\"use strict\";\r\n\r\nmodule.exports = PropertyValue;\r\n\r\nvar SyntaxUnit = require(\"../util/SyntaxUnit\");\r\n\r\nvar Parser = require(\"./Parser\");\r\n\r\n/**\r\n * Represents a single part of a CSS property value, meaning that it represents\r\n * just everything single part between \":\" and \";\". If there are multiple values\r\n * separated by commas, this type represents just one of the values.\r\n * @param {String[]} parts An array of value parts making up this value.\r\n * @param {int} line The line of text on which the unit resides.\r\n * @param {int} col The column of text on which the unit resides.\r\n * @namespace parserlib.css\r\n * @class PropertyValue\r\n * @extends parserlib.util.SyntaxUnit\r\n * @constructor\r\n */\r\nfunction PropertyValue(parts, line, col) {\r\n\r\n    SyntaxUnit.call(this, parts.join(\" \"), line, col, Parser.PROPERTY_VALUE_TYPE);\r\n\r\n    /**\r\n     * The parts that make up the selector.\r\n     * @type Array\r\n     * @property parts\r\n     */\r\n    this.parts = parts;\r\n\r\n}\r\n\r\nPropertyValue.prototype = new SyntaxUnit();\r\nPropertyValue.prototype.constructor = PropertyValue;\r\n\r\n","/home/travis/build/npmtest/node-npmtest-parserlib/node_modules/parserlib/src/css/PropertyValuePart.js":"\"use strict\";\r\n\r\nmodule.exports = PropertyValuePart;\r\n\r\nvar SyntaxUnit = require(\"../util/SyntaxUnit\");\r\n\r\nvar Colors = require(\"./Colors\");\r\nvar Parser = require(\"./Parser\");\r\nvar Tokens = require(\"./Tokens\");\r\n\r\n/**\r\n * Represents a single part of a CSS property value, meaning that it represents\r\n * just one part of the data between \":\" and \";\".\r\n * @param {String} text The text representation of the unit.\r\n * @param {int} line The line of text on which the unit resides.\r\n * @param {int} col The column of text on which the unit resides.\r\n * @namespace parserlib.css\r\n * @class PropertyValuePart\r\n * @extends parserlib.util.SyntaxUnit\r\n * @constructor\r\n */\r\nfunction PropertyValuePart(text, line, col, optionalHint) {\r\n    var hint = optionalHint || {};\r\n\r\n    SyntaxUnit.call(this, text, line, col, Parser.PROPERTY_VALUE_PART_TYPE);\r\n\r\n    /**\r\n     * Indicates the type of value unit.\r\n     * @type String\r\n     * @property type\r\n     */\r\n    this.type = \"unknown\";\r\n\r\n    //figure out what type of data it is\r\n\r\n    var temp;\r\n\r\n    //it is a measurement?\r\n    if (/^([+\\-]?[\\d\\.]+)([a-z]+)$/i.test(text)) {  //dimension\r\n        this.type = \"dimension\";\r\n        this.value = +RegExp.$1;\r\n        this.units = RegExp.$2;\r\n\r\n        //try to narrow down\r\n        switch (this.units.toLowerCase()) {\r\n\r\n            case \"em\":\r\n            case \"rem\":\r\n            case \"ex\":\r\n            case \"px\":\r\n            case \"cm\":\r\n            case \"mm\":\r\n            case \"in\":\r\n            case \"pt\":\r\n            case \"pc\":\r\n            case \"ch\":\r\n            case \"vh\":\r\n            case \"vw\":\r\n            case \"vmax\":\r\n            case \"vmin\":\r\n                this.type = \"length\";\r\n                break;\r\n\r\n            case \"fr\":\r\n                this.type = \"grid\";\r\n                break;\r\n\r\n            case \"deg\":\r\n            case \"rad\":\r\n            case \"grad\":\r\n            case \"turn\":\r\n                this.type = \"angle\";\r\n                break;\r\n\r\n            case \"ms\":\r\n            case \"s\":\r\n                this.type = \"time\";\r\n                break;\r\n\r\n            case \"hz\":\r\n            case \"khz\":\r\n                this.type = \"frequency\";\r\n                break;\r\n\r\n            case \"dpi\":\r\n            case \"dpcm\":\r\n                this.type = \"resolution\";\r\n                break;\r\n\r\n            //default\r\n\r\n        }\r\n\r\n    } else if (/^([+\\-]?[\\d\\.]+)%$/i.test(text)) {  //percentage\r\n        this.type = \"percentage\";\r\n        this.value = +RegExp.$1;\r\n    } else if (/^([+\\-]?\\d+)$/i.test(text)) {  //integer\r\n        this.type = \"integer\";\r\n        this.value = +RegExp.$1;\r\n    } else if (/^([+\\-]?[\\d\\.]+)$/i.test(text)) {  //number\r\n        this.type = \"number\";\r\n        this.value = +RegExp.$1;\r\n\r\n    } else if (/^#([a-f0-9]{3,6})/i.test(text)) {  //hexcolor\r\n        this.type = \"color\";\r\n        temp = RegExp.$1;\r\n        if (temp.length === 3) {\r\n            this.red    = parseInt(temp.charAt(0)+temp.charAt(0), 16);\r\n            this.green  = parseInt(temp.charAt(1)+temp.charAt(1), 16);\r\n            this.blue   = parseInt(temp.charAt(2)+temp.charAt(2), 16);\r\n        } else {\r\n            this.red    = parseInt(temp.substring(0, 2), 16);\r\n            this.green  = parseInt(temp.substring(2, 4), 16);\r\n            this.blue   = parseInt(temp.substring(4, 6), 16);\r\n        }\r\n    } else if (/^rgb\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)/i.test(text)) { //rgb() color with absolute numbers\r\n        this.type   = \"color\";\r\n        this.red    = +RegExp.$1;\r\n        this.green  = +RegExp.$2;\r\n        this.blue   = +RegExp.$3;\r\n    } else if (/^rgb\\(\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*\\)/i.test(text)) { //rgb() color with percentages\r\n        this.type   = \"color\";\r\n        this.red    = +RegExp.$1 * 255 / 100;\r\n        this.green  = +RegExp.$2 * 255 / 100;\r\n        this.blue   = +RegExp.$3 * 255 / 100;\r\n    } else if (/^rgba\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*([\\d\\.]+)\\s*\\)/i.test(text)) { //rgba() color with absolute numbers\r\n        this.type   = \"color\";\r\n        this.red    = +RegExp.$1;\r\n        this.green  = +RegExp.$2;\r\n        this.blue   = +RegExp.$3;\r\n        this.alpha  = +RegExp.$4;\r\n    } else if (/^rgba\\(\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*,\\s*([\\d\\.]+)\\s*\\)/i.test(text)) { //rgba() color with percentages\r\n        this.type   = \"color\";\r\n        this.red    = +RegExp.$1 * 255 / 100;\r\n        this.green  = +RegExp.$2 * 255 / 100;\r\n        this.blue   = +RegExp.$3 * 255 / 100;\r\n        this.alpha  = +RegExp.$4;\r\n    } else if (/^hsl\\(\\s*(\\d+)\\s*,\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*\\)/i.test(text)) { //hsl()\r\n        this.type   = \"color\";\r\n        this.hue    = +RegExp.$1;\r\n        this.saturation = +RegExp.$2 / 100;\r\n        this.lightness  = +RegExp.$3 / 100;\r\n    } else if (/^hsla\\(\\s*(\\d+)\\s*,\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*,\\s*([\\d\\.]+)\\s*\\)/i.test(text)) { //hsla() color with percentages\r\n        this.type   = \"color\";\r\n        this.hue    = +RegExp.$1;\r\n        this.saturation = +RegExp.$2 / 100;\r\n        this.lightness  = +RegExp.$3 / 100;\r\n        this.alpha  = +RegExp.$4;\r\n    } else if (/^url\\((\"([^\\\\\"]|\\\\.)*\")\\)/i.test(text)) { //URI\r\n        // generated by TokenStream.readURI, so always double-quoted.\r\n        this.type   = \"uri\";\r\n        this.uri    = PropertyValuePart.parseString(RegExp.$1);\r\n    } else if (/^([^\\(]+)\\(/i.test(text)) {\r\n        this.type   = \"function\";\r\n        this.name   = RegExp.$1;\r\n        this.value  = text;\r\n    } else if (/^\"([^\\n\\r\\f\\\\\"]|\\\\\\r\\n|\\\\[^\\r0-9a-f]|\\\\[0-9a-f]{1,6}(\\r\\n|[ \\n\\r\\t\\f])?)*\"/i.test(text)) {    //double-quoted string\r\n        this.type   = \"string\";\r\n        this.value  = PropertyValuePart.parseString(text);\r\n    } else if (/^'([^\\n\\r\\f\\\\']|\\\\\\r\\n|\\\\[^\\r0-9a-f]|\\\\[0-9a-f]{1,6}(\\r\\n|[ \\n\\r\\t\\f])?)*'/i.test(text)) {    //single-quoted string\r\n        this.type   = \"string\";\r\n        this.value  = PropertyValuePart.parseString(text);\r\n    } else if (Colors[text.toLowerCase()]) {  //named color\r\n        this.type   = \"color\";\r\n        temp        = Colors[text.toLowerCase()].substring(1);\r\n        this.red    = parseInt(temp.substring(0, 2), 16);\r\n        this.green  = parseInt(temp.substring(2, 4), 16);\r\n        this.blue   = parseInt(temp.substring(4, 6), 16);\r\n    } else if (/^[,\\/]$/.test(text)) {\r\n        this.type   = \"operator\";\r\n        this.value  = text;\r\n    } else if (/^-?[a-z_\\u00A0-\\uFFFF][a-z0-9\\-_\\u00A0-\\uFFFF]*$/i.test(text)) {\r\n        this.type   = \"identifier\";\r\n        this.value  = text;\r\n    }\r\n\r\n    // There can be ambiguity with escape sequences in identifiers, as\r\n    // well as with \"color\" parts which are also \"identifiers\", so record\r\n    // an explicit hint when the token generating this PropertyValuePart\r\n    // was an identifier.\r\n    this.wasIdent = Boolean(hint.ident);\r\n\r\n}\r\n\r\nPropertyValuePart.prototype = new SyntaxUnit();\r\nPropertyValuePart.prototype.constructor = PropertyValuePart;\r\n\r\n/**\r\n * Helper method to parse a CSS string.\r\n */\r\nPropertyValuePart.parseString = function(str) {\r\n    str = str.slice(1, -1); // Strip surrounding single/double quotes\r\n    var replacer = function(match, esc) {\r\n        if (/^(\\n|\\r\\n|\\r|\\f)$/.test(esc)) {\r\n            return \"\";\r\n        }\r\n        var m = /^[0-9a-f]{1,6}/i.exec(esc);\r\n        if (m) {\r\n            var codePoint = parseInt(m[0], 16);\r\n            if (String.fromCodePoint) {\r\n                return String.fromCodePoint(codePoint);\r\n            } else {\r\n                // XXX No support for surrogates on old JavaScript engines.\r\n                return String.fromCharCode(codePoint);\r\n            }\r\n        }\r\n        return esc;\r\n    };\r\n    return str.replace(/\\\\(\\r\\n|[^\\r0-9a-f]|[0-9a-f]{1,6}(\\r\\n|[ \\n\\r\\t\\f])?)/ig,\r\n                       replacer);\r\n};\r\n\r\n/**\r\n * Helper method to serialize a CSS string.\r\n */\r\nPropertyValuePart.serializeString = function(value) {\r\n    var replacer = function(match, c) {\r\n        if (c === \"\\\"\") {\r\n            return \"\\\\\" + c;\r\n        }\r\n        var cp = String.codePointAt ? String.codePointAt(0) :\r\n            // We only escape non-surrogate chars, so using charCodeAt\r\n            // is harmless here.\r\n            String.charCodeAt(0);\r\n        return \"\\\\\" + cp.toString(16) + \" \";\r\n    };\r\n    return \"\\\"\" + value.replace(/[\"\\r\\n\\f]/g, replacer) + \"\\\"\";\r\n};\r\n\r\n/**\r\n * Create a new syntax unit based solely on the given token.\r\n * Convenience method for creating a new syntax unit when\r\n * it represents a single token instead of multiple.\r\n * @param {Object} token The token object to represent.\r\n * @return {parserlib.css.PropertyValuePart} The object representing the token.\r\n * @static\r\n * @method fromToken\r\n */\r\nPropertyValuePart.fromToken = function(token) {\r\n    var part = new PropertyValuePart(token.value, token.startLine, token.startCol, {\r\n        // Tokens can have escaped characters that would fool the type\r\n        // identification in the PropertyValuePart constructor, so pass\r\n        // in a hint if this was an identifier.\r\n        ident: token.type === Tokens.IDENT\r\n    });\r\n    return part;\r\n};\r\n","/home/travis/build/npmtest/node-npmtest-parserlib/node_modules/parserlib/src/css/Tokens.js":"\"use strict\";\r\n\r\nvar Tokens = module.exports = [\r\n\r\n    /*\r\n     * The following token names are defined in CSS3 Grammar: https://www.w3.org/TR/css3-syntax/#lexical\r\n     */\r\n\r\n    // HTML-style comments\r\n    { name: \"CDO\" },\r\n    { name: \"CDC\" },\r\n\r\n    // ignorables\r\n    { name: \"S\", whitespace: true/*, channel: \"ws\"*/ },\r\n    { name: \"COMMENT\", comment: true, hide: true, channel: \"comment\" },\r\n\r\n    // attribute equality\r\n    { name: \"INCLUDES\", text: \"~=\" },\r\n    { name: \"DASHMATCH\", text: \"|=\" },\r\n    { name: \"PREFIXMATCH\", text: \"^=\" },\r\n    { name: \"SUFFIXMATCH\", text: \"$=\" },\r\n    { name: \"SUBSTRINGMATCH\", text: \"*=\" },\r\n\r\n    // identifier types\r\n    { name: \"STRING\" },\r\n    { name: \"IDENT\" },\r\n    { name: \"HASH\" },\r\n\r\n    // at-keywords\r\n    { name: \"IMPORT_SYM\", text: \"@import\" },\r\n    { name: \"PAGE_SYM\", text: \"@page\" },\r\n    { name: \"MEDIA_SYM\", text: \"@media\" },\r\n    { name: \"FONT_FACE_SYM\", text: \"@font-face\" },\r\n    { name: \"CHARSET_SYM\", text: \"@charset\" },\r\n    { name: \"NAMESPACE_SYM\", text: \"@namespace\" },\r\n    { name: \"SUPPORTS_SYM\", text: \"@supports\" },\r\n    { name: \"VIEWPORT_SYM\", text: [\"@viewport\", \"@-ms-viewport\", \"@-o-viewport\"] },\r\n    { name: \"DOCUMENT_SYM\", text: [\"@document\", \"@-moz-document\"] },\r\n    { name: \"UNKNOWN_SYM\" },\r\n    //{ name: \"ATKEYWORD\"},\r\n\r\n    // CSS3 animations\r\n    { name: \"KEYFRAMES_SYM\", text: [ \"@keyframes\", \"@-webkit-keyframes\", \"@-moz-keyframes\", \"@-o-keyframes\" ] },\r\n\r\n    // important symbol\r\n    { name: \"IMPORTANT_SYM\" },\r\n\r\n    // measurements\r\n    { name: \"LENGTH\" },\r\n    { name: \"ANGLE\" },\r\n    { name: \"TIME\" },\r\n    { name: \"FREQ\" },\r\n    { name: \"DIMENSION\" },\r\n    { name: \"PERCENTAGE\" },\r\n    { name: \"NUMBER\" },\r\n\r\n    // functions\r\n    { name: \"URI\" },\r\n    { name: \"FUNCTION\" },\r\n\r\n    // Unicode ranges\r\n    { name: \"UNICODE_RANGE\" },\r\n\r\n    /*\r\n     * The following token names are defined in CSS3 Selectors: https://www.w3.org/TR/css3-selectors/#selector-syntax\r\n     */\r\n\r\n    // invalid string\r\n    { name: \"INVALID\" },\r\n\r\n    // combinators\r\n    { name: \"PLUS\", text: \"+\" },\r\n    { name: \"GREATER\", text: \">\" },\r\n    { name: \"COMMA\", text: \",\" },\r\n    { name: \"TILDE\", text: \"~\" },\r\n\r\n    // modifier\r\n    { name: \"NOT\" },\r\n\r\n    /*\r\n     * Defined in CSS3 Paged Media\r\n     */\r\n    { name: \"TOPLEFTCORNER_SYM\", text: \"@top-left-corner\" },\r\n    { name: \"TOPLEFT_SYM\", text: \"@top-left\" },\r\n    { name: \"TOPCENTER_SYM\", text: \"@top-center\" },\r\n    { name: \"TOPRIGHT_SYM\", text: \"@top-right\" },\r\n    { name: \"TOPRIGHTCORNER_SYM\", text: \"@top-right-corner\" },\r\n    { name: \"BOTTOMLEFTCORNER_SYM\", text: \"@bottom-left-corner\" },\r\n    { name: \"BOTTOMLEFT_SYM\", text: \"@bottom-left\" },\r\n    { name: \"BOTTOMCENTER_SYM\", text: \"@bottom-center\" },\r\n    { name: \"BOTTOMRIGHT_SYM\", text: \"@bottom-right\" },\r\n    { name: \"BOTTOMRIGHTCORNER_SYM\", text: \"@bottom-right-corner\" },\r\n    { name: \"LEFTTOP_SYM\", text: \"@left-top\" },\r\n    { name: \"LEFTMIDDLE_SYM\", text: \"@left-middle\" },\r\n    { name: \"LEFTBOTTOM_SYM\", text: \"@left-bottom\" },\r\n    { name: \"RIGHTTOP_SYM\", text: \"@right-top\" },\r\n    { name: \"RIGHTMIDDLE_SYM\", text: \"@right-middle\" },\r\n    { name: \"RIGHTBOTTOM_SYM\", text: \"@right-bottom\" },\r\n\r\n    /*\r\n     * The following token names are defined in CSS3 Media Queries: https://www.w3.org/TR/css3-mediaqueries/#syntax\r\n     */\r\n    /*{ name: \"MEDIA_ONLY\", state: \"media\"},\r\n    { name: \"MEDIA_NOT\", state: \"media\"},\r\n    { name: \"MEDIA_AND\", state: \"media\"},*/\r\n    { name: \"RESOLUTION\", state: \"media\" },\r\n\r\n    /*\r\n     * The following token names are not defined in any CSS specification but are used by the lexer.\r\n     */\r\n\r\n    // not a real token, but useful for stupid IE filters\r\n    { name: \"IE_FUNCTION\" },\r\n\r\n    // part of CSS3 grammar but not the Flex code\r\n    { name: \"CHAR\" },\r\n\r\n    // TODO: Needed?\r\n    // Not defined as tokens, but might as well be\r\n    {\r\n        name: \"PIPE\",\r\n        text: \"|\"\r\n    },\r\n    {\r\n        name: \"SLASH\",\r\n        text: \"/\"\r\n    },\r\n    {\r\n        name: \"MINUS\",\r\n        text: \"-\"\r\n    },\r\n    {\r\n        name: \"STAR\",\r\n        text: \"*\"\r\n    },\r\n\r\n    {\r\n        name: \"LBRACE\",\r\n        endChar: \"}\",\r\n        text: \"{\"\r\n    },\r\n    {\r\n        name: \"RBRACE\",\r\n        text: \"}\"\r\n    },\r\n    {\r\n        name: \"LBRACKET\",\r\n        endChar: \"]\",\r\n        text: \"[\"\r\n    },\r\n    {\r\n        name: \"RBRACKET\",\r\n        text: \"]\"\r\n    },\r\n    {\r\n        name: \"EQUALS\",\r\n        text: \"=\"\r\n    },\r\n    {\r\n        name: \"COLON\",\r\n        text: \":\"\r\n    },\r\n    {\r\n        name: \"SEMICOLON\",\r\n        text: \";\"\r\n    },\r\n    {\r\n        name: \"LPAREN\",\r\n        endChar: \")\",\r\n        text: \"(\"\r\n    },\r\n    {\r\n        name: \"RPAREN\",\r\n        text: \")\"\r\n    },\r\n    {\r\n        name: \"DOT\",\r\n        text: \".\"\r\n    }\r\n];\r\n\r\n(function() {\r\n    var nameMap = [],\r\n        typeMap = Object.create(null);\r\n\r\n    Tokens.UNKNOWN = -1;\r\n    Tokens.unshift({ name:\"EOF\" });\r\n    for (var i=0, len = Tokens.length; i < len; i++) {\r\n        nameMap.push(Tokens[i].name);\r\n        Tokens[Tokens[i].name] = i;\r\n        if (Tokens[i].text) {\r\n            if (Tokens[i].text instanceof Array) {\r\n                for (var j=0; j < Tokens[i].text.length; j++) {\r\n                    typeMap[Tokens[i].text[j]] = i;\r\n                }\r\n            } else {\r\n                typeMap[Tokens[i].text] = i;\r\n            }\r\n        }\r\n    }\r\n\r\n    Tokens.name = function(tt) {\r\n        return nameMap[tt];\r\n    };\r\n\r\n    Tokens.type = function(c) {\r\n        return typeMap[c] || -1;\r\n    };\r\n})();\r\n","/home/travis/build/npmtest/node-npmtest-parserlib/node_modules/parserlib/src/css/Selector.js":"\"use strict\";\r\n\r\nmodule.exports = Selector;\r\n\r\nvar SyntaxUnit = require(\"../util/SyntaxUnit\");\r\n\r\nvar Parser = require(\"./Parser\");\r\nvar Specificity = require(\"./Specificity\");\r\n\r\n/**\r\n * Represents an entire single selector, including all parts but not\r\n * including multiple selectors (those separated by commas).\r\n * @namespace parserlib.css\r\n * @class Selector\r\n * @extends parserlib.util.SyntaxUnit\r\n * @constructor\r\n * @param {Array} parts Array of selectors parts making up this selector.\r\n * @param {int} line The line of text on which the unit resides.\r\n * @param {int} col The column of text on which the unit resides.\r\n */\r\nfunction Selector(parts, line, col) {\r\n\r\n    SyntaxUnit.call(this, parts.join(\" \"), line, col, Parser.SELECTOR_TYPE);\r\n\r\n    /**\r\n     * The parts that make up the selector.\r\n     * @type Array\r\n     * @property parts\r\n     */\r\n    this.parts = parts;\r\n\r\n    /**\r\n     * The specificity of the selector.\r\n     * @type parserlib.css.Specificity\r\n     * @property specificity\r\n     */\r\n    this.specificity = Specificity.calculate(this);\r\n\r\n}\r\n\r\nSelector.prototype = new SyntaxUnit();\r\nSelector.prototype.constructor = Selector;\r\n\r\n","/home/travis/build/npmtest/node-npmtest-parserlib/node_modules/parserlib/src/css/Specificity.js":"\"use strict\";\r\n\r\nmodule.exports = Specificity;\r\n\r\nvar Pseudos = require(\"./Pseudos\");\r\nvar SelectorPart = require(\"./SelectorPart\");\r\n\r\n/**\r\n * Represents a selector's specificity.\r\n * @namespace parserlib.css\r\n * @class Specificity\r\n * @constructor\r\n * @param {int} a Should be 1 for inline styles, zero for stylesheet styles\r\n * @param {int} b Number of ID selectors\r\n * @param {int} c Number of classes and pseudo classes\r\n * @param {int} d Number of element names and pseudo elements\r\n */\r\nfunction Specificity(a, b, c, d) {\r\n    this.a = a;\r\n    this.b = b;\r\n    this.c = c;\r\n    this.d = d;\r\n}\r\n\r\nSpecificity.prototype = {\r\n    constructor: Specificity,\r\n\r\n    /**\r\n     * Compare this specificity to another.\r\n     * @param {Specificity} other The other specificity to compare to.\r\n     * @return {int} -1 if the other specificity is larger, 1 if smaller, 0 if equal.\r\n     * @method compare\r\n     */\r\n    compare: function(other) {\r\n        var comps = [\"a\", \"b\", \"c\", \"d\"],\r\n            i, len;\r\n\r\n        for (i=0, len=comps.length; i < len; i++) {\r\n            if (this[comps[i]] < other[comps[i]]) {\r\n                return -1;\r\n            } else if (this[comps[i]] > other[comps[i]]) {\r\n                return 1;\r\n            }\r\n        }\r\n\r\n        return 0;\r\n    },\r\n\r\n    /**\r\n     * Creates a numeric value for the specificity.\r\n     * @return {int} The numeric value for the specificity.\r\n     * @method valueOf\r\n     */\r\n    valueOf: function() {\r\n        return (this.a * 1000) + (this.b * 100) + (this.c * 10) + this.d;\r\n    },\r\n\r\n    /**\r\n     * Returns a string representation for specificity.\r\n     * @return {String} The string representation of specificity.\r\n     * @method toString\r\n     */\r\n    toString: function() {\r\n        return this.a + \",\" + this.b + \",\" + this.c + \",\" + this.d;\r\n    }\r\n\r\n};\r\n\r\n/**\r\n * Calculates the specificity of the given selector.\r\n * @param {parserlib.css.Selector} The selector to calculate specificity for.\r\n * @return {parserlib.css.Specificity} The specificity of the selector.\r\n * @static\r\n * @method calculate\r\n */\r\nSpecificity.calculate = function(selector) {\r\n\r\n    var i, len,\r\n        part,\r\n        b=0, c=0, d=0;\r\n\r\n    function updateValues(part) {\r\n\r\n        var i, j, len, num,\r\n            elementName = part.elementName ? part.elementName.text : \"\",\r\n            modifier;\r\n\r\n        if (elementName && elementName.charAt(elementName.length-1) !== \"*\") {\r\n            d++;\r\n        }\r\n\r\n        for (i=0, len=part.modifiers.length; i < len; i++) {\r\n            modifier = part.modifiers[i];\r\n            switch (modifier.type) {\r\n                case \"class\":\r\n                case \"attribute\":\r\n                    c++;\r\n                    break;\r\n\r\n                case \"id\":\r\n                    b++;\r\n                    break;\r\n\r\n                case \"pseudo\":\r\n                    if (Pseudos.isElement(modifier.text)) {\r\n                        d++;\r\n                    } else {\r\n                        c++;\r\n                    }\r\n                    break;\r\n\r\n                case \"not\":\r\n                    for (j=0, num=modifier.args.length; j < num; j++) {\r\n                        updateValues(modifier.args[j]);\r\n                    }\r\n            }\r\n        }\r\n    }\r\n\r\n    for (i=0, len=selector.parts.length; i < len; i++) {\r\n        part = selector.parts[i];\r\n\r\n        if (part instanceof SelectorPart) {\r\n            updateValues(part);\r\n        }\r\n    }\r\n\r\n    return new Specificity(0, b, c, d);\r\n};\r\n","/home/travis/build/npmtest/node-npmtest-parserlib/node_modules/parserlib/src/css/Pseudos.js":"\"use strict\";\r\n\r\nvar Pseudos = module.exports = {\r\n    __proto__:       null,\r\n    \":first-letter\": 1,\r\n    \":first-line\":   1,\r\n    \":before\":       1,\r\n    \":after\":        1\r\n};\r\n\r\nPseudos.ELEMENT = 1;\r\nPseudos.CLASS = 2;\r\n\r\nPseudos.isElement = function(pseudo) {\r\n    return pseudo.indexOf(\"::\") === 0 || Pseudos[pseudo.toLowerCase()] === Pseudos.ELEMENT;\r\n};\r\n","/home/travis/build/npmtest/node-npmtest-parserlib/node_modules/parserlib/src/css/SelectorPart.js":"\"use strict\";\r\n\r\nmodule.exports = SelectorPart;\r\n\r\nvar SyntaxUnit = require(\"../util/SyntaxUnit\");\r\n\r\nvar Parser = require(\"./Parser\");\r\n\r\n/**\r\n * Represents a single part of a selector string, meaning a single set of\r\n * element name and modifiers. This does not include combinators such as\r\n * spaces, +, >, etc.\r\n * @namespace parserlib.css\r\n * @class SelectorPart\r\n * @extends parserlib.util.SyntaxUnit\r\n * @constructor\r\n * @param {String} elementName The element name in the selector or null\r\n *      if there is no element name.\r\n * @param {Array} modifiers Array of individual modifiers for the element.\r\n *      May be empty if there are none.\r\n * @param {String} text The text representation of the unit.\r\n * @param {int} line The line of text on which the unit resides.\r\n * @param {int} col The column of text on which the unit resides.\r\n */\r\nfunction SelectorPart(elementName, modifiers, text, line, col) {\r\n\r\n    SyntaxUnit.call(this, text, line, col, Parser.SELECTOR_PART_TYPE);\r\n\r\n    /**\r\n     * The tag name of the element to which this part\r\n     * of the selector affects.\r\n     * @type String\r\n     * @property elementName\r\n     */\r\n    this.elementName = elementName;\r\n\r\n    /**\r\n     * The parts that come after the element name, such as class names, IDs,\r\n     * pseudo classes/elements, etc.\r\n     * @type Array\r\n     * @property modifiers\r\n     */\r\n    this.modifiers = modifiers;\r\n\r\n}\r\n\r\nSelectorPart.prototype = new SyntaxUnit();\r\nSelectorPart.prototype.constructor = SelectorPart;\r\n\r\n","/home/travis/build/npmtest/node-npmtest-parserlib/node_modules/parserlib/src/css/SelectorSubPart.js":"\"use strict\";\r\n\r\nmodule.exports = SelectorSubPart;\r\n\r\nvar SyntaxUnit = require(\"../util/SyntaxUnit\");\r\n\r\nvar Parser = require(\"./Parser\");\r\n\r\n/**\r\n * Represents a selector modifier string, meaning a class name, element name,\r\n * element ID, pseudo rule, etc.\r\n * @namespace parserlib.css\r\n * @class SelectorSubPart\r\n * @extends parserlib.util.SyntaxUnit\r\n * @constructor\r\n * @param {String} text The text representation of the unit.\r\n * @param {String} type The type of selector modifier.\r\n * @param {int} line The line of text on which the unit resides.\r\n * @param {int} col The column of text on which the unit resides.\r\n */\r\nfunction SelectorSubPart(text, type, line, col) {\r\n\r\n    SyntaxUnit.call(this, text, line, col, Parser.SELECTOR_SUB_PART_TYPE);\r\n\r\n    /**\r\n     * The type of modifier.\r\n     * @type String\r\n     * @property type\r\n     */\r\n    this.type = type;\r\n\r\n    /**\r\n     * Some subparts have arguments, this represents them.\r\n     * @type Array\r\n     * @property args\r\n     */\r\n    this.args = [];\r\n\r\n}\r\n\r\nSelectorSubPart.prototype = new SyntaxUnit();\r\nSelectorSubPart.prototype.constructor = SelectorSubPart;\r\n\r\n","/home/travis/build/npmtest/node-npmtest-parserlib/node_modules/parserlib/src/css/TokenStream.js":"\"use strict\";\r\n\r\nmodule.exports = TokenStream;\r\n\r\nvar TokenStreamBase = require(\"../util/TokenStreamBase\");\r\n\r\nvar PropertyValuePart = require(\"./PropertyValuePart\");\r\nvar Tokens = require(\"./Tokens\");\r\n\r\nvar h = /^[0-9a-fA-F]$/,\r\n    nonascii = /^[\\u00A0-\\uFFFF]$/,\r\n    nl = /\\n|\\r\\n|\\r|\\f/,\r\n    whitespace = /\\u0009|\\u000a|\\u000c|\\u000d|\\u0020/;\r\n\r\n//-----------------------------------------------------------------------------\r\n// Helper functions\r\n//-----------------------------------------------------------------------------\r\n\r\n\r\nfunction isHexDigit(c) {\r\n    return c !== null && h.test(c);\r\n}\r\n\r\nfunction isDigit(c) {\r\n    return c !== null && /\\d/.test(c);\r\n}\r\n\r\nfunction isWhitespace(c) {\r\n    return c !== null && whitespace.test(c);\r\n}\r\n\r\nfunction isNewLine(c) {\r\n    return c !== null && nl.test(c);\r\n}\r\n\r\nfunction isNameStart(c) {\r\n    return c !== null && /[a-z_\\u00A0-\\uFFFF\\\\]/i.test(c);\r\n}\r\n\r\nfunction isNameChar(c) {\r\n    return c !== null && (isNameStart(c) || /[0-9\\-\\\\]/.test(c));\r\n}\r\n\r\nfunction isIdentStart(c) {\r\n    return c !== null && (isNameStart(c) || /\\-\\\\/.test(c));\r\n}\r\n\r\nfunction mix(receiver, supplier) {\r\n    for (var prop in supplier) {\r\n        if (Object.prototype.hasOwnProperty.call(supplier, prop)) {\r\n            receiver[prop] = supplier[prop];\r\n        }\r\n    }\r\n    return receiver;\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// CSS Token Stream\r\n//-----------------------------------------------------------------------------\r\n\r\n\r\n/**\r\n * A token stream that produces CSS tokens.\r\n * @param {String|Reader} input The source of text to tokenize.\r\n * @constructor\r\n * @class TokenStream\r\n * @namespace parserlib.css\r\n */\r\nfunction TokenStream(input) {\r\n    TokenStreamBase.call(this, input, Tokens);\r\n}\r\n\r\nTokenStream.prototype = mix(new TokenStreamBase(), {\r\n\r\n    /**\r\n     * Overrides the TokenStreamBase method of the same name\r\n     * to produce CSS tokens.\r\n     * @return {Object} A token object representing the next token.\r\n     * @method _getToken\r\n     * @private\r\n     */\r\n    _getToken: function() {\r\n\r\n        var c,\r\n            reader = this._reader,\r\n            token   = null,\r\n            startLine   = reader.getLine(),\r\n            startCol    = reader.getCol();\r\n\r\n        c = reader.read();\r\n\r\n\r\n        while (c) {\r\n            switch (c) {\r\n\r\n                /*\r\n                 * Potential tokens:\r\n                 * - COMMENT\r\n                 * - SLASH\r\n                 * - CHAR\r\n                 */\r\n                case \"/\":\r\n\r\n                    if (reader.peek() === \"*\") {\r\n                        token = this.commentToken(c, startLine, startCol);\r\n                    } else {\r\n                        token = this.charToken(c, startLine, startCol);\r\n                    }\r\n                    break;\r\n\r\n                /*\r\n                 * Potential tokens:\r\n                 * - DASHMATCH\r\n                 * - INCLUDES\r\n                 * - PREFIXMATCH\r\n                 * - SUFFIXMATCH\r\n                 * - SUBSTRINGMATCH\r\n                 * - CHAR\r\n                 */\r\n                case \"|\":\r\n                case \"~\":\r\n                case \"^\":\r\n                case \"$\":\r\n                case \"*\":\r\n                    if (reader.peek() === \"=\") {\r\n                        token = this.comparisonToken(c, startLine, startCol);\r\n                    } else {\r\n                        token = this.charToken(c, startLine, startCol);\r\n                    }\r\n                    break;\r\n\r\n                /*\r\n                 * Potential tokens:\r\n                 * - STRING\r\n                 * - INVALID\r\n                 */\r\n                case \"\\\"\":\r\n                case \"'\":\r\n                    token = this.stringToken(c, startLine, startCol);\r\n                    break;\r\n\r\n                /*\r\n                 * Potential tokens:\r\n                 * - HASH\r\n                 * - CHAR\r\n                 */\r\n                case \"#\":\r\n                    if (isNameChar(reader.peek())) {\r\n                        token = this.hashToken(c, startLine, startCol);\r\n                    } else {\r\n                        token = this.charToken(c, startLine, startCol);\r\n                    }\r\n                    break;\r\n\r\n                /*\r\n                 * Potential tokens:\r\n                 * - DOT\r\n                 * - NUMBER\r\n                 * - DIMENSION\r\n                 * - PERCENTAGE\r\n                 */\r\n                case \".\":\r\n                    if (isDigit(reader.peek())) {\r\n                        token = this.numberToken(c, startLine, startCol);\r\n                    } else {\r\n                        token = this.charToken(c, startLine, startCol);\r\n                    }\r\n                    break;\r\n\r\n                /*\r\n                 * Potential tokens:\r\n                 * - CDC\r\n                 * - MINUS\r\n                 * - NUMBER\r\n                 * - DIMENSION\r\n                 * - PERCENTAGE\r\n                 */\r\n                case \"-\":\r\n                    if (reader.peek() === \"-\") {  //could be closing HTML-style comment\r\n                        token = this.htmlCommentEndToken(c, startLine, startCol);\r\n                    } else if (isNameStart(reader.peek())) {\r\n                        token = this.identOrFunctionToken(c, startLine, startCol);\r\n                    } else {\r\n                        token = this.charToken(c, startLine, startCol);\r\n                    }\r\n                    break;\r\n\r\n                /*\r\n                 * Potential tokens:\r\n                 * - IMPORTANT_SYM\r\n                 * - CHAR\r\n                 */\r\n                case \"!\":\r\n                    token = this.importantToken(c, startLine, startCol);\r\n                    break;\r\n\r\n                /*\r\n                 * Any at-keyword or CHAR\r\n                 */\r\n                case \"@\":\r\n                    token = this.atRuleToken(c, startLine, startCol);\r\n                    break;\r\n\r\n                /*\r\n                 * Potential tokens:\r\n                 * - NOT\r\n                 * - CHAR\r\n                 */\r\n                case \":\":\r\n                    token = this.notToken(c, startLine, startCol);\r\n                    break;\r\n\r\n                /*\r\n                 * Potential tokens:\r\n                 * - CDO\r\n                 * - CHAR\r\n                 */\r\n                case \"<\":\r\n                    token = this.htmlCommentStartToken(c, startLine, startCol);\r\n                    break;\r\n\r\n                /*\r\n                 * Potential tokens:\r\n                 * - IDENT\r\n                 * - CHAR\r\n                 */\r\n                case \"\\\\\":\r\n                    if (/[^\\r\\n\\f]/.test(reader.peek())) {\r\n                        token = this.identOrFunctionToken(this.readEscape(c, true), startLine, startCol);\r\n                    } else {\r\n                        token = this.charToken(c, startLine, startCol);\r\n                    }\r\n                    break;\r\n\r\n                /*\r\n                 * Potential tokens:\r\n                 * - UNICODE_RANGE\r\n                 * - URL\r\n                 * - CHAR\r\n                 */\r\n                case \"U\":\r\n                case \"u\":\r\n                    if (reader.peek() === \"+\") {\r\n                        token = this.unicodeRangeToken(c, startLine, startCol);\r\n                        break;\r\n                    }\r\n                    /* falls through */\r\n                default:\r\n\r\n                    /*\r\n                     * Potential tokens:\r\n                     * - NUMBER\r\n                     * - DIMENSION\r\n                     * - LENGTH\r\n                     * - FREQ\r\n                     * - TIME\r\n                     * - EMS\r\n                     * - EXS\r\n                     * - ANGLE\r\n                     */\r\n                    if (isDigit(c)) {\r\n                        token = this.numberToken(c, startLine, startCol);\r\n                    } else\r\n\r\n                    /*\r\n                     * Potential tokens:\r\n                     * - S\r\n                     */\r\n                    if (isWhitespace(c)) {\r\n                        token = this.whitespaceToken(c, startLine, startCol);\r\n                    } else\r\n\r\n                    /*\r\n                     * Potential tokens:\r\n                     * - IDENT\r\n                     */\r\n                    if (isIdentStart(c)) {\r\n                        token = this.identOrFunctionToken(c, startLine, startCol);\r\n                    } else {\r\n                       /*\r\n                        * Potential tokens:\r\n                        * - CHAR\r\n                        * - PLUS\r\n                        */\r\n                        token = this.charToken(c, startLine, startCol);\r\n                    }\r\n\r\n            }\r\n\r\n            //make sure this token is wanted\r\n            //TODO: check channel\r\n            break;\r\n        }\r\n\r\n        if (!token && c === null) {\r\n            token = this.createToken(Tokens.EOF, null, startLine, startCol);\r\n        }\r\n\r\n        return token;\r\n    },\r\n\r\n    //-------------------------------------------------------------------------\r\n    // Methods to create tokens\r\n    //-------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Produces a token based on available data and the current\r\n     * reader position information. This method is called by other\r\n     * private methods to create tokens and is never called directly.\r\n     * @param {int} tt The token type.\r\n     * @param {String} value The text value of the token.\r\n     * @param {int} startLine The beginning line for the character.\r\n     * @param {int} startCol The beginning column for the character.\r\n     * @param {Object} options (Optional) Specifies a channel property\r\n     *      to indicate that a different channel should be scanned\r\n     *      and/or a hide property indicating that the token should\r\n     *      be hidden.\r\n     * @return {Object} A token object.\r\n     * @method createToken\r\n     */\r\n    createToken: function(tt, value, startLine, startCol, options) {\r\n        var reader = this._reader;\r\n        options = options || {};\r\n\r\n        return {\r\n            value:      value,\r\n            type:       tt,\r\n            channel:    options.channel,\r\n            endChar:    options.endChar,\r\n            hide:       options.hide || false,\r\n            startLine:  startLine,\r\n            startCol:   startCol,\r\n            endLine:    reader.getLine(),\r\n            endCol:     reader.getCol()\r\n        };\r\n    },\r\n\r\n    //-------------------------------------------------------------------------\r\n    // Methods to create specific tokens\r\n    //-------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Produces a token for any at-rule. If the at-rule is unknown, then\r\n     * the token is for a single \"@\" character.\r\n     * @param {String} first The first character for the token.\r\n     * @param {int} startLine The beginning line for the character.\r\n     * @param {int} startCol The beginning column for the character.\r\n     * @return {Object} A token object.\r\n     * @method atRuleToken\r\n     */\r\n    atRuleToken: function(first, startLine, startCol) {\r\n        var rule    = first,\r\n            reader  = this._reader,\r\n            tt      = Tokens.CHAR,\r\n            ident;\r\n\r\n        /*\r\n         * First, mark where we are. There are only four @ rules,\r\n         * so anything else is really just an invalid token.\r\n         * Basically, if this doesn't match one of the known @\r\n         * rules, just return '@' as an unknown token and allow\r\n         * parsing to continue after that point.\r\n         */\r\n        reader.mark();\r\n\r\n        //try to find the at-keyword\r\n        ident = this.readName();\r\n        rule = first + ident;\r\n        tt = Tokens.type(rule.toLowerCase());\r\n\r\n        //if it's not valid, use the first character only and reset the reader\r\n        if (tt === Tokens.CHAR || tt === Tokens.UNKNOWN) {\r\n            if (rule.length > 1) {\r\n                tt = Tokens.UNKNOWN_SYM;\r\n            } else {\r\n                tt = Tokens.CHAR;\r\n                rule = first;\r\n                reader.reset();\r\n            }\r\n        }\r\n\r\n        return this.createToken(tt, rule, startLine, startCol);\r\n    },\r\n\r\n    /**\r\n     * Produces a character token based on the given character\r\n     * and location in the stream. If there's a special (non-standard)\r\n     * token name, this is used; otherwise CHAR is used.\r\n     * @param {String} c The character for the token.\r\n     * @param {int} startLine The beginning line for the character.\r\n     * @param {int} startCol The beginning column for the character.\r\n     * @return {Object} A token object.\r\n     * @method charToken\r\n     */\r\n    charToken: function(c, startLine, startCol) {\r\n        var tt = Tokens.type(c);\r\n        var opts = {};\r\n\r\n        if (tt === -1) {\r\n            tt = Tokens.CHAR;\r\n        } else {\r\n            opts.endChar = Tokens[tt].endChar;\r\n        }\r\n\r\n        return this.createToken(tt, c, startLine, startCol, opts);\r\n    },\r\n\r\n    /**\r\n     * Produces a character token based on the given character\r\n     * and location in the stream. If there's a special (non-standard)\r\n     * token name, this is used; otherwise CHAR is used.\r\n     * @param {String} first The first character for the token.\r\n     * @param {int} startLine The beginning line for the character.\r\n     * @param {int} startCol The beginning column for the character.\r\n     * @return {Object} A token object.\r\n     * @method commentToken\r\n     */\r\n    commentToken: function(first, startLine, startCol) {\r\n        var comment = this.readComment(first);\r\n\r\n        return this.createToken(Tokens.COMMENT, comment, startLine, startCol);\r\n    },\r\n\r\n    /**\r\n     * Produces a comparison token based on the given character\r\n     * and location in the stream. The next character must be\r\n     * read and is already known to be an equals sign.\r\n     * @param {String} c The character for the token.\r\n     * @param {int} startLine The beginning line for the character.\r\n     * @param {int} startCol The beginning column for the character.\r\n     * @return {Object} A token object.\r\n     * @method comparisonToken\r\n     */\r\n    comparisonToken: function(c, startLine, startCol) {\r\n        var reader  = this._reader,\r\n            comparison  = c + reader.read(),\r\n            tt      = Tokens.type(comparison) || Tokens.CHAR;\r\n\r\n        return this.createToken(tt, comparison, startLine, startCol);\r\n    },\r\n\r\n    /**\r\n     * Produces a hash token based on the specified information. The\r\n     * first character provided is the pound sign (#) and then this\r\n     * method reads a name afterward.\r\n     * @param {String} first The first character (#) in the hash name.\r\n     * @param {int} startLine The beginning line for the character.\r\n     * @param {int} startCol The beginning column for the character.\r\n     * @return {Object} A token object.\r\n     * @method hashToken\r\n     */\r\n    hashToken: function(first, startLine, startCol) {\r\n        var name    = this.readName(first);\r\n\r\n        return this.createToken(Tokens.HASH, name, startLine, startCol);\r\n    },\r\n\r\n    /**\r\n     * Produces a CDO or CHAR token based on the specified information. The\r\n     * first character is provided and the rest is read by the function to determine\r\n     * the correct token to create.\r\n     * @param {String} first The first character in the token.\r\n     * @param {int} startLine The beginning line for the character.\r\n     * @param {int} startCol The beginning column for the character.\r\n     * @return {Object} A token object.\r\n     * @method htmlCommentStartToken\r\n     */\r\n    htmlCommentStartToken: function(first, startLine, startCol) {\r\n        var reader      = this._reader,\r\n            text        = first;\r\n\r\n        reader.mark();\r\n        text += reader.readCount(3);\r\n\r\n        if (text === \"<!--\") {\r\n            return this.createToken(Tokens.CDO, text, startLine, startCol);\r\n        } else {\r\n            reader.reset();\r\n            return this.charToken(first, startLine, startCol);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Produces a CDC or CHAR token based on the specified information. The\r\n     * first character is provided and the rest is read by the function to determine\r\n     * the correct token to create.\r\n     * @param {String} first The first character in the token.\r\n     * @param {int} startLine The beginning line for the character.\r\n     * @param {int} startCol The beginning column for the character.\r\n     * @return {Object} A token object.\r\n     * @method htmlCommentEndToken\r\n     */\r\n    htmlCommentEndToken: function(first, startLine, startCol) {\r\n        var reader      = this._reader,\r\n            text        = first;\r\n\r\n        reader.mark();\r\n        text += reader.readCount(2);\r\n\r\n        if (text === \"-->\") {\r\n            return this.createToken(Tokens.CDC, text, startLine, startCol);\r\n        } else {\r\n            reader.reset();\r\n            return this.charToken(first, startLine, startCol);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Produces an IDENT or FUNCTION token based on the specified information. The\r\n     * first character is provided and the rest is read by the function to determine\r\n     * the correct token to create.\r\n     * @param {String} first The first character in the identifier.\r\n     * @param {int} startLine The beginning line for the character.\r\n     * @param {int} startCol The beginning column for the character.\r\n     * @return {Object} A token object.\r\n     * @method identOrFunctionToken\r\n     */\r\n    identOrFunctionToken: function(first, startLine, startCol) {\r\n        var reader  = this._reader,\r\n            ident   = this.readName(first),\r\n            tt      = Tokens.IDENT,\r\n            uriFns  = [\"url(\", \"url-prefix(\", \"domain(\"],\r\n            uri;\r\n\r\n        //if there's a left paren immediately after, it's a URI or function\r\n        if (reader.peek() === \"(\") {\r\n            ident += reader.read();\r\n            if (uriFns.indexOf(ident.toLowerCase()) > -1) {\r\n                reader.mark();\r\n                uri = this.readURI(ident);\r\n                if (uri === null) {\r\n                    //didn't find a valid URL or there's no closing paren\r\n                    reader.reset();\r\n                    tt = Tokens.FUNCTION;\r\n                } else {\r\n                    tt = Tokens.URI;\r\n                    ident = uri;\r\n                }\r\n            } else {\r\n                tt = Tokens.FUNCTION;\r\n            }\r\n        } else if (reader.peek() === \":\") {  //might be an IE function\r\n\r\n            //IE-specific functions always being with progid:\r\n            if (ident.toLowerCase() === \"progid\") {\r\n                ident += reader.readTo(\"(\");\r\n                tt = Tokens.IE_FUNCTION;\r\n            }\r\n        }\r\n\r\n        return this.createToken(tt, ident, startLine, startCol);\r\n    },\r\n\r\n    /**\r\n     * Produces an IMPORTANT_SYM or CHAR token based on the specified information. The\r\n     * first character is provided and the rest is read by the function to determine\r\n     * the correct token to create.\r\n     * @param {String} first The first character in the token.\r\n     * @param {int} startLine The beginning line for the character.\r\n     * @param {int} startCol The beginning column for the character.\r\n     * @return {Object} A token object.\r\n     * @method importantToken\r\n     */\r\n    importantToken: function(first, startLine, startCol) {\r\n        var reader      = this._reader,\r\n            important   = first,\r\n            tt          = Tokens.CHAR,\r\n            temp,\r\n            c;\r\n\r\n        reader.mark();\r\n        c = reader.read();\r\n\r\n        while (c) {\r\n\r\n            //there can be a comment in here\r\n            if (c === \"/\") {\r\n\r\n                //if the next character isn't a star, then this isn't a valid !important token\r\n                if (reader.peek() !== \"*\") {\r\n                    break;\r\n                } else {\r\n                    temp = this.readComment(c);\r\n                    if (temp === \"\") {    //broken!\r\n                        break;\r\n                    }\r\n                }\r\n            } else if (isWhitespace(c)) {\r\n                important += c + this.readWhitespace();\r\n            } else if (/i/i.test(c)) {\r\n                temp = reader.readCount(8);\r\n                if (/mportant/i.test(temp)) {\r\n                    important += c + temp;\r\n                    tt = Tokens.IMPORTANT_SYM;\r\n\r\n                }\r\n                break;  //we're done\r\n            } else {\r\n                break;\r\n            }\r\n\r\n            c = reader.read();\r\n        }\r\n\r\n        if (tt === Tokens.CHAR) {\r\n            reader.reset();\r\n            return this.charToken(first, startLine, startCol);\r\n        } else {\r\n            return this.createToken(tt, important, startLine, startCol);\r\n        }\r\n\r\n\r\n    },\r\n\r\n    /**\r\n     * Produces a NOT or CHAR token based on the specified information. The\r\n     * first character is provided and the rest is read by the function to determine\r\n     * the correct token to create.\r\n     * @param {String} first The first character in the token.\r\n     * @param {int} startLine The beginning line for the character.\r\n     * @param {int} startCol The beginning column for the character.\r\n     * @return {Object} A token object.\r\n     * @method notToken\r\n     */\r\n    notToken: function(first, startLine, startCol) {\r\n        var reader      = this._reader,\r\n            text        = first;\r\n\r\n        reader.mark();\r\n        text += reader.readCount(4);\r\n\r\n        if (text.toLowerCase() === \":not(\") {\r\n            return this.createToken(Tokens.NOT, text, startLine, startCol);\r\n        } else {\r\n            reader.reset();\r\n            return this.charToken(first, startLine, startCol);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Produces a number token based on the given character\r\n     * and location in the stream. This may return a token of\r\n     * NUMBER, EMS, EXS, LENGTH, ANGLE, TIME, FREQ, DIMENSION,\r\n     * or PERCENTAGE.\r\n     * @param {String} first The first character for the token.\r\n     * @param {int} startLine The beginning line for the character.\r\n     * @param {int} startCol The beginning column for the character.\r\n     * @return {Object} A token object.\r\n     * @method numberToken\r\n     */\r\n    numberToken: function(first, startLine, startCol) {\r\n        var reader  = this._reader,\r\n            value   = this.readNumber(first),\r\n            ident,\r\n            tt      = Tokens.NUMBER,\r\n            c       = reader.peek();\r\n\r\n        if (isIdentStart(c)) {\r\n            ident = this.readName(reader.read());\r\n            value += ident;\r\n\r\n            if (/^em$|^ex$|^px$|^gd$|^rem$|^vw$|^vh$|^vmax$|^vmin$|^ch$|^cm$|^mm$|^in$|^pt$|^pc$/i.test(ident)) {\r\n                tt = Tokens.LENGTH;\r\n            } else if (/^deg|^rad$|^grad$|^turn$/i.test(ident)) {\r\n                tt = Tokens.ANGLE;\r\n            } else if (/^ms$|^s$/i.test(ident)) {\r\n                tt = Tokens.TIME;\r\n            } else if (/^hz$|^khz$/i.test(ident)) {\r\n                tt = Tokens.FREQ;\r\n            } else if (/^dpi$|^dpcm$/i.test(ident)) {\r\n                tt = Tokens.RESOLUTION;\r\n            } else {\r\n                tt = Tokens.DIMENSION;\r\n            }\r\n\r\n        } else if (c === \"%\") {\r\n            value += reader.read();\r\n            tt = Tokens.PERCENTAGE;\r\n        }\r\n\r\n        return this.createToken(tt, value, startLine, startCol);\r\n    },\r\n\r\n    /**\r\n     * Produces a string token based on the given character\r\n     * and location in the stream. Since strings may be indicated\r\n     * by single or double quotes, a failure to match starting\r\n     * and ending quotes results in an INVALID token being generated.\r\n     * The first character in the string is passed in and then\r\n     * the rest are read up to and including the final quotation mark.\r\n     * @param {String} first The first character in the string.\r\n     * @param {int} startLine The beginning line for the character.\r\n     * @param {int} startCol The beginning column for the character.\r\n     * @return {Object} A token object.\r\n     * @method stringToken\r\n     */\r\n    stringToken: function(first, startLine, startCol) {\r\n        var delim   = first,\r\n            string  = first,\r\n            reader  = this._reader,\r\n            tt      = Tokens.STRING,\r\n            c       = reader.read(),\r\n            i;\r\n\r\n        while (c) {\r\n            string += c;\r\n\r\n            if (c === \"\\\\\") {\r\n                c = reader.read();\r\n                if (c === null) {\r\n                    break; // premature EOF after backslash\r\n                } else if (/[^\\r\\n\\f0-9a-f]/i.test(c)) {\r\n                    // single-character escape\r\n                    string += c;\r\n                } else {\r\n                    // read up to six hex digits\r\n                    for (i=0; isHexDigit(c) && i<6; i++) {\r\n                        string += c;\r\n                        c = reader.read();\r\n                    }\r\n                    // swallow trailing newline or space\r\n                    if (c === \"\\r\" && reader.peek() === \"\\n\") {\r\n                        string += c;\r\n                        c = reader.read();\r\n                    }\r\n                    if (isWhitespace(c)) {\r\n                        string += c;\r\n                    } else {\r\n                        // This character is null or not part of the escape;\r\n                        // jump back to the top to process it.\r\n                        continue;\r\n                    }\r\n                }\r\n            } else if (c === delim) {\r\n                break; // delimiter found.\r\n            } else if (isNewLine(reader.peek())) {\r\n                // newline without an escapement: it's an invalid string\r\n                tt = Tokens.INVALID;\r\n                break;\r\n            }\r\n            c = reader.read();\r\n        }\r\n\r\n        //if c is null, that means we're out of input and the string was never closed\r\n        if (c === null) {\r\n            tt = Tokens.INVALID;\r\n        }\r\n\r\n        return this.createToken(tt, string, startLine, startCol);\r\n    },\r\n\r\n    unicodeRangeToken: function(first, startLine, startCol) {\r\n        var reader  = this._reader,\r\n            value   = first,\r\n            temp,\r\n            tt      = Tokens.CHAR;\r\n\r\n        //then it should be a unicode range\r\n        if (reader.peek() === \"+\") {\r\n            reader.mark();\r\n            value += reader.read();\r\n            value += this.readUnicodeRangePart(true);\r\n\r\n            //ensure there's an actual unicode range here\r\n            if (value.length === 2) {\r\n                reader.reset();\r\n            } else {\r\n\r\n                tt = Tokens.UNICODE_RANGE;\r\n\r\n                //if there's a ? in the first part, there can't be a second part\r\n                if (value.indexOf(\"?\") === -1) {\r\n\r\n                    if (reader.peek() === \"-\") {\r\n                        reader.mark();\r\n                        temp = reader.read();\r\n                        temp += this.readUnicodeRangePart(false);\r\n\r\n                        //if there's not another value, back up and just take the first\r\n                        if (temp.length === 1) {\r\n                            reader.reset();\r\n                        } else {\r\n                            value += temp;\r\n                        }\r\n                    }\r\n\r\n                }\r\n            }\r\n        }\r\n\r\n        return this.createToken(tt, value, startLine, startCol);\r\n    },\r\n\r\n    /**\r\n     * Produces a S token based on the specified information. Since whitespace\r\n     * may have multiple characters, this consumes all whitespace characters\r\n     * into a single token.\r\n     * @param {String} first The first character in the token.\r\n     * @param {int} startLine The beginning line for the character.\r\n     * @param {int} startCol The beginning column for the character.\r\n     * @return {Object} A token object.\r\n     * @method whitespaceToken\r\n     */\r\n    whitespaceToken: function(first, startLine, startCol) {\r\n        var value   = first + this.readWhitespace();\r\n        return this.createToken(Tokens.S, value, startLine, startCol);\r\n    },\r\n\r\n\r\n    //-------------------------------------------------------------------------\r\n    // Methods to read values from the string stream\r\n    //-------------------------------------------------------------------------\r\n\r\n    readUnicodeRangePart: function(allowQuestionMark) {\r\n        var reader  = this._reader,\r\n            part = \"\",\r\n            c       = reader.peek();\r\n\r\n        //first read hex digits\r\n        while (isHexDigit(c) && part.length < 6) {\r\n            reader.read();\r\n            part += c;\r\n            c = reader.peek();\r\n        }\r\n\r\n        //then read question marks if allowed\r\n        if (allowQuestionMark) {\r\n            while (c === \"?\" && part.length < 6) {\r\n                reader.read();\r\n                part += c;\r\n                c = reader.peek();\r\n            }\r\n        }\r\n\r\n        //there can't be any other characters after this point\r\n\r\n        return part;\r\n    },\r\n\r\n    readWhitespace: function() {\r\n        var reader  = this._reader,\r\n            whitespace = \"\",\r\n            c       = reader.peek();\r\n\r\n        while (isWhitespace(c)) {\r\n            reader.read();\r\n            whitespace += c;\r\n            c = reader.peek();\r\n        }\r\n\r\n        return whitespace;\r\n    },\r\n    readNumber: function(first) {\r\n        var reader  = this._reader,\r\n            number  = first,\r\n            hasDot  = (first === \".\"),\r\n            c       = reader.peek();\r\n\r\n\r\n        while (c) {\r\n            if (isDigit(c)) {\r\n                number += reader.read();\r\n            } else if (c === \".\") {\r\n                if (hasDot) {\r\n                    break;\r\n                } else {\r\n                    hasDot = true;\r\n                    number += reader.read();\r\n                }\r\n            } else {\r\n                break;\r\n            }\r\n\r\n            c = reader.peek();\r\n        }\r\n\r\n        return number;\r\n    },\r\n\r\n    // returns null w/o resetting reader if string is invalid.\r\n    readString: function() {\r\n        var token = this.stringToken(this._reader.read(), 0, 0);\r\n        return token.type === Tokens.INVALID ? null : token.value;\r\n    },\r\n\r\n    // returns null w/o resetting reader if URI is invalid.\r\n    readURI: function(first) {\r\n        var reader  = this._reader,\r\n            uri     = first,\r\n            inner   = \"\",\r\n            c       = reader.peek();\r\n\r\n        //skip whitespace before\r\n        while (c && isWhitespace(c)) {\r\n            reader.read();\r\n            c = reader.peek();\r\n        }\r\n\r\n        //it's a string\r\n        if (c === \"'\" || c === \"\\\"\") {\r\n            inner = this.readString();\r\n            if (inner !== null) {\r\n                inner = PropertyValuePart.parseString(inner);\r\n            }\r\n        } else {\r\n            inner = this.readUnquotedURL();\r\n        }\r\n\r\n        c = reader.peek();\r\n\r\n        //skip whitespace after\r\n        while (c && isWhitespace(c)) {\r\n            reader.read();\r\n            c = reader.peek();\r\n        }\r\n\r\n        //if there was no inner value or the next character isn't closing paren, it's not a URI\r\n        if (inner === null || c !== \")\") {\r\n            uri = null;\r\n        } else {\r\n            // Ensure argument to URL is always double-quoted\r\n            // (This simplifies later processing in PropertyValuePart.)\r\n            uri += PropertyValuePart.serializeString(inner) + reader.read();\r\n        }\r\n\r\n        return uri;\r\n    },\r\n    // This method never fails, although it may return an empty string.\r\n    readUnquotedURL: function(first) {\r\n        var reader  = this._reader,\r\n            url     = first || \"\",\r\n            c;\r\n\r\n        for (c = reader.peek(); c; c = reader.peek()) {\r\n            // Note that the grammar at\r\n            // https://www.w3.org/TR/CSS2/grammar.html#scanner\r\n            // incorrectly includes the backslash character in the\r\n            // `url` production, although it is correctly omitted in\r\n            // the `baduri1` production.\r\n            if (nonascii.test(c) || /^[\\-!#$%&*-\\[\\]-~]$/.test(c)) {\r\n                url += c;\r\n                reader.read();\r\n            } else if (c === \"\\\\\") {\r\n                if (/^[^\\r\\n\\f]$/.test(reader.peek(2))) {\r\n                    url += this.readEscape(reader.read(), true);\r\n                } else {\r\n                    break; // bad escape sequence.\r\n                }\r\n            } else {\r\n                break; // bad character\r\n            }\r\n        }\r\n\r\n        return url;\r\n    },\r\n\r\n    readName: function(first) {\r\n        var reader  = this._reader,\r\n            ident   = first || \"\",\r\n            c;\r\n\r\n        for (c = reader.peek(); c; c = reader.peek()) {\r\n            if (c === \"\\\\\") {\r\n                if (/^[^\\r\\n\\f]$/.test(reader.peek(2))) {\r\n                    ident += this.readEscape(reader.read(), true);\r\n                } else {\r\n                    // Bad escape sequence.\r\n                    break;\r\n                }\r\n            } else if (isNameChar(c)) {\r\n                ident += reader.read();\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n\r\n        return ident;\r\n    },\r\n\r\n    readEscape: function(first, unescape) {\r\n        var reader  = this._reader,\r\n            cssEscape = first || \"\",\r\n            i       = 0,\r\n            c       = reader.peek();\r\n\r\n        if (isHexDigit(c)) {\r\n            do {\r\n                cssEscape += reader.read();\r\n                c = reader.peek();\r\n            } while (c && isHexDigit(c) && ++i < 6);\r\n        }\r\n\r\n        if (cssEscape.length === 1) {\r\n            if (/^[^\\r\\n\\f0-9a-f]$/.test(c)) {\r\n                reader.read();\r\n                if (unescape) {\r\n                    return c;\r\n                }\r\n            } else {\r\n                // We should never get here (readName won't call readEscape\r\n                // if the escape sequence is bad).\r\n                throw new Error(\"Bad escape sequence.\");\r\n            }\r\n        } else if (c === \"\\r\") {\r\n            reader.read();\r\n            if (reader.peek() === \"\\n\") {\r\n                c += reader.read();\r\n            }\r\n        } else if (/^[ \\t\\n\\f]$/.test(c)) {\r\n            reader.read();\r\n        } else {\r\n            c = \"\";\r\n        }\r\n\r\n        if (unescape) {\r\n            var cp = parseInt(cssEscape.slice(first.length), 16);\r\n            return String.fromCodePoint ? String.fromCodePoint(cp) :\r\n                String.fromCharCode(cp);\r\n        }\r\n        return cssEscape + c;\r\n    },\r\n\r\n    readComment: function(first) {\r\n        var reader  = this._reader,\r\n            comment = first || \"\",\r\n            c       = reader.read();\r\n\r\n        if (c === \"*\") {\r\n            while (c) {\r\n                comment += c;\r\n\r\n                //look for end of comment\r\n                if (comment.length > 2 && c === \"*\" && reader.peek() === \"/\") {\r\n                    comment += reader.read();\r\n                    break;\r\n                }\r\n\r\n                c = reader.read();\r\n            }\r\n\r\n            return comment;\r\n        } else {\r\n            return \"\";\r\n        }\r\n\r\n    }\r\n});\r\n","/home/travis/build/npmtest/node-npmtest-parserlib/node_modules/parserlib/src/util/TokenStreamBase.js":"\"use strict\";\r\n\r\nmodule.exports = TokenStreamBase;\r\n\r\nvar StringReader = require(\"./StringReader\");\r\nvar SyntaxError = require(\"./SyntaxError\");\r\n\r\n/**\r\n * Generic TokenStream providing base functionality.\r\n * @class TokenStreamBase\r\n * @namespace parserlib.util\r\n * @constructor\r\n * @param {String|StringReader} input The text to tokenize or a reader from\r\n *      which to read the input.\r\n */\r\nfunction TokenStreamBase(input, tokenData) {\r\n\r\n    /**\r\n     * The string reader for easy access to the text.\r\n     * @type StringReader\r\n     * @property _reader\r\n     * @private\r\n     */\r\n    this._reader = new StringReader(input ? input.toString() : \"\");\r\n\r\n    /**\r\n     * Token object for the last consumed token.\r\n     * @type Token\r\n     * @property _token\r\n     * @private\r\n     */\r\n    this._token = null;\r\n\r\n    /**\r\n     * The array of token information.\r\n     * @type Array\r\n     * @property _tokenData\r\n     * @private\r\n     */\r\n    this._tokenData = tokenData;\r\n\r\n    /**\r\n     * Lookahead token buffer.\r\n     * @type Array\r\n     * @property _lt\r\n     * @private\r\n     */\r\n    this._lt = [];\r\n\r\n    /**\r\n     * Lookahead token buffer index.\r\n     * @type int\r\n     * @property _ltIndex\r\n     * @private\r\n     */\r\n    this._ltIndex = 0;\r\n\r\n    this._ltIndexCache = [];\r\n}\r\n\r\n/**\r\n * Accepts an array of token information and outputs\r\n * an array of token data containing key-value mappings\r\n * and matching functions that the TokenStream needs.\r\n * @param {Array} tokens An array of token descriptors.\r\n * @return {Array} An array of processed token data.\r\n * @method createTokenData\r\n * @static\r\n */\r\nTokenStreamBase.createTokenData = function(tokens) {\r\n\r\n    var nameMap     = [],\r\n        typeMap     = Object.create(null),\r\n        tokenData     = tokens.concat([]),\r\n        i            = 0,\r\n        len            = tokenData.length+1;\r\n\r\n    tokenData.UNKNOWN = -1;\r\n    tokenData.unshift({ name:\"EOF\" });\r\n\r\n    for (; i < len; i++) {\r\n        nameMap.push(tokenData[i].name);\r\n        tokenData[tokenData[i].name] = i;\r\n        if (tokenData[i].text) {\r\n            typeMap[tokenData[i].text] = i;\r\n        }\r\n    }\r\n\r\n    tokenData.name = function(tt) {\r\n        return nameMap[tt];\r\n    };\r\n\r\n    tokenData.type = function(c) {\r\n        return typeMap[c];\r\n    };\r\n\r\n    return tokenData;\r\n};\r\n\r\nTokenStreamBase.prototype = {\r\n\r\n    //restore constructor\r\n    constructor: TokenStreamBase,\r\n\r\n    //-------------------------------------------------------------------------\r\n    // Matching methods\r\n    //-------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Determines if the next token matches the given token type.\r\n     * If so, that token is consumed; if not, the token is placed\r\n     * back onto the token stream. You can pass in any number of\r\n     * token types and this will return true if any of the token\r\n     * types is found.\r\n     * @param {int|int[]} tokenTypes Either a single token type or an array of\r\n     *      token types that the next token might be. If an array is passed,\r\n     *      it's assumed that the token can be any of these.\r\n     * @param {variant} channel (Optional) The channel to read from. If not\r\n     *      provided, reads from the default (unnamed) channel.\r\n     * @return {Boolean} True if the token type matches, false if not.\r\n     * @method match\r\n     */\r\n    match: function(tokenTypes, channel) {\r\n\r\n        //always convert to an array, makes things easier\r\n        if (!(tokenTypes instanceof Array)) {\r\n            tokenTypes = [tokenTypes];\r\n        }\r\n\r\n        var tt  = this.get(channel),\r\n            i   = 0,\r\n            len = tokenTypes.length;\r\n\r\n        while (i < len) {\r\n            if (tt === tokenTypes[i++]) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        //no match found, put the token back\r\n        this.unget();\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * Determines if the next token matches the given token type.\r\n     * If so, that token is consumed; if not, an error is thrown.\r\n     * @param {int|int[]} tokenTypes Either a single token type or an array of\r\n     *      token types that the next token should be. If an array is passed,\r\n     *      it's assumed that the token must be one of these.\r\n     * @return {void}\r\n     * @method mustMatch\r\n     */\r\n    mustMatch: function(tokenTypes) {\r\n\r\n        var token;\r\n\r\n        //always convert to an array, makes things easier\r\n        if (!(tokenTypes instanceof Array)) {\r\n            tokenTypes = [tokenTypes];\r\n        }\r\n\r\n        if (!this.match.apply(this, arguments)) {\r\n            token = this.LT(1);\r\n            throw new SyntaxError(\"Expected \" + this._tokenData[tokenTypes[0]].name +\r\n                \" at line \" + token.startLine + \", col \" + token.startCol + \".\", token.startLine, token.startCol);\r\n        }\r\n    },\r\n\r\n    //-------------------------------------------------------------------------\r\n    // Consuming methods\r\n    //-------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Keeps reading from the token stream until either one of the specified\r\n     * token types is found or until the end of the input is reached.\r\n     * @param {int|int[]} tokenTypes Either a single token type or an array of\r\n     *      token types that the next token should be. If an array is passed,\r\n     *      it's assumed that the token must be one of these.\r\n     * @param {variant} channel (Optional) The channel to read from. If not\r\n     *      provided, reads from the default (unnamed) channel.\r\n     * @return {void}\r\n     * @method advance\r\n     */\r\n    advance: function(tokenTypes, channel) {\r\n\r\n        while (this.LA(0) !== 0 && !this.match(tokenTypes, channel)) {\r\n            this.get();\r\n        }\r\n\r\n        return this.LA(0);\r\n    },\r\n\r\n    /**\r\n     * Consumes the next token from the token stream.\r\n     * @return {int} The token type of the token that was just consumed.\r\n     * @method get\r\n     */\r\n    get: function(channel) {\r\n\r\n        var tokenInfo   = this._tokenData,\r\n            i           =0,\r\n            token,\r\n            info;\r\n\r\n        //check the lookahead buffer first\r\n        if (this._lt.length && this._ltIndex >= 0 && this._ltIndex < this._lt.length) {\r\n\r\n            i++;\r\n            this._token = this._lt[this._ltIndex++];\r\n            info = tokenInfo[this._token.type];\r\n\r\n            //obey channels logic\r\n            while ((info.channel !== undefined && channel !== info.channel) &&\r\n                    this._ltIndex < this._lt.length) {\r\n                this._token = this._lt[this._ltIndex++];\r\n                info = tokenInfo[this._token.type];\r\n                i++;\r\n            }\r\n\r\n            //here be dragons\r\n            if ((info.channel === undefined || channel === info.channel) &&\r\n                    this._ltIndex <= this._lt.length) {\r\n                this._ltIndexCache.push(i);\r\n                return this._token.type;\r\n            }\r\n        }\r\n\r\n        //call token retriever method\r\n        token = this._getToken();\r\n\r\n        //if it should be hidden, don't save a token\r\n        if (token.type > -1 && !tokenInfo[token.type].hide) {\r\n\r\n            //apply token channel\r\n            token.channel = tokenInfo[token.type].channel;\r\n\r\n            //save for later\r\n            this._token = token;\r\n            this._lt.push(token);\r\n\r\n            //save space that will be moved (must be done before array is truncated)\r\n            this._ltIndexCache.push(this._lt.length - this._ltIndex + i);\r\n\r\n            //keep the buffer under 5 items\r\n            if (this._lt.length > 5) {\r\n                this._lt.shift();\r\n            }\r\n\r\n            //also keep the shift buffer under 5 items\r\n            if (this._ltIndexCache.length > 5) {\r\n                this._ltIndexCache.shift();\r\n            }\r\n\r\n            //update lookahead index\r\n            this._ltIndex = this._lt.length;\r\n        }\r\n\r\n        /*\r\n         * Skip to the next token if:\r\n         * 1. The token type is marked as hidden.\r\n         * 2. The token type has a channel specified and it isn't the current channel.\r\n         */\r\n        info = tokenInfo[token.type];\r\n        if (info &&\r\n                (info.hide ||\r\n                (info.channel !== undefined && channel !== info.channel))) {\r\n            return this.get(channel);\r\n        } else {\r\n            //return just the type\r\n            return token.type;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Looks ahead a certain number of tokens and returns the token type at\r\n     * that position. This will throw an error if you lookahead past the\r\n     * end of input, past the size of the lookahead buffer, or back past\r\n     * the first token in the lookahead buffer.\r\n     * @param {int} The index of the token type to retrieve. 0 for the\r\n     *      current token, 1 for the next, -1 for the previous, etc.\r\n     * @return {int} The token type of the token in the given position.\r\n     * @method LA\r\n     */\r\n    LA: function(index) {\r\n        var total = index,\r\n            tt;\r\n        if (index > 0) {\r\n            //TODO: Store 5 somewhere\r\n            if (index > 5) {\r\n                throw new Error(\"Too much lookahead.\");\r\n            }\r\n\r\n            //get all those tokens\r\n            while (total) {\r\n                tt = this.get();\r\n                total--;\r\n            }\r\n\r\n            //unget all those tokens\r\n            while (total < index) {\r\n                this.unget();\r\n                total++;\r\n            }\r\n        } else if (index < 0) {\r\n\r\n            if (this._lt[this._ltIndex+index]) {\r\n                tt = this._lt[this._ltIndex+index].type;\r\n            } else {\r\n                throw new Error(\"Too much lookbehind.\");\r\n            }\r\n\r\n        } else {\r\n            tt = this._token.type;\r\n        }\r\n\r\n        return tt;\r\n\r\n    },\r\n\r\n    /**\r\n     * Looks ahead a certain number of tokens and returns the token at\r\n     * that position. This will throw an error if you lookahead past the\r\n     * end of input, past the size of the lookahead buffer, or back past\r\n     * the first token in the lookahead buffer.\r\n     * @param {int} The index of the token type to retrieve. 0 for the\r\n     *      current token, 1 for the next, -1 for the previous, etc.\r\n     * @return {Object} The token of the token in the given position.\r\n     * @method LA\r\n     */\r\n    LT: function(index) {\r\n\r\n        //lookahead first to prime the token buffer\r\n        this.LA(index);\r\n\r\n        //now find the token, subtract one because _ltIndex is already at the next index\r\n        return this._lt[this._ltIndex+index-1];\r\n    },\r\n\r\n    /**\r\n     * Returns the token type for the next token in the stream without\r\n     * consuming it.\r\n     * @return {int} The token type of the next token in the stream.\r\n     * @method peek\r\n     */\r\n    peek: function() {\r\n        return this.LA(1);\r\n    },\r\n\r\n    /**\r\n     * Returns the actual token object for the last consumed token.\r\n     * @return {Token} The token object for the last consumed token.\r\n     * @method token\r\n     */\r\n    token: function() {\r\n        return this._token;\r\n    },\r\n\r\n    /**\r\n     * Returns the name of the token for the given token type.\r\n     * @param {int} tokenType The type of token to get the name of.\r\n     * @return {String} The name of the token or \"UNKNOWN_TOKEN\" for any\r\n     *      invalid token type.\r\n     * @method tokenName\r\n     */\r\n    tokenName: function(tokenType) {\r\n        if (tokenType < 0 || tokenType > this._tokenData.length) {\r\n            return \"UNKNOWN_TOKEN\";\r\n        } else {\r\n            return this._tokenData[tokenType].name;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Returns the token type value for the given token name.\r\n     * @param {String} tokenName The name of the token whose value should be returned.\r\n     * @return {int} The token type value for the given token name or -1\r\n     *      for an unknown token.\r\n     * @method tokenName\r\n     */\r\n    tokenType: function(tokenName) {\r\n        return this._tokenData[tokenName] || -1;\r\n    },\r\n\r\n    /**\r\n     * Returns the last consumed token to the token stream.\r\n     * @method unget\r\n     */\r\n    unget: function() {\r\n        //if (this._ltIndex > -1) {\r\n        if (this._ltIndexCache.length) {\r\n            this._ltIndex -= this._ltIndexCache.pop();//--;\r\n            this._token = this._lt[this._ltIndex - 1];\r\n        } else {\r\n            throw new Error(\"Too much lookahead.\");\r\n        }\r\n    }\r\n\r\n};\r\n\r\n","/home/travis/build/npmtest/node-npmtest-parserlib/node_modules/parserlib/src/util/StringReader.js":"\"use strict\";\r\n\r\nmodule.exports = StringReader;\r\n\r\n/**\r\n * Convenient way to read through strings.\r\n * @namespace parserlib.util\r\n * @class StringReader\r\n * @constructor\r\n * @param {String} text The text to read.\r\n */\r\nfunction StringReader(text) {\r\n\r\n    /**\r\n     * The input text with line endings normalized.\r\n     * @property _input\r\n     * @type String\r\n     * @private\r\n     */\r\n    this._input = text.replace(/(\\r\\n?|\\n)/g, \"\\n\");\r\n\r\n\r\n    /**\r\n     * The row for the character to be read next.\r\n     * @property _line\r\n     * @type int\r\n     * @private\r\n     */\r\n    this._line = 1;\r\n\r\n\r\n    /**\r\n     * The column for the character to be read next.\r\n     * @property _col\r\n     * @type int\r\n     * @private\r\n     */\r\n    this._col = 1;\r\n\r\n    /**\r\n     * The index of the character in the input to be read next.\r\n     * @property _cursor\r\n     * @type int\r\n     * @private\r\n     */\r\n    this._cursor = 0;\r\n}\r\n\r\nStringReader.prototype = {\r\n\r\n    // restore constructor\r\n    constructor: StringReader,\r\n\r\n    //-------------------------------------------------------------------------\r\n    // Position info\r\n    //-------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Returns the column of the character to be read next.\r\n     * @return {int} The column of the character to be read next.\r\n     * @method getCol\r\n     */\r\n    getCol: function() {\r\n        return this._col;\r\n    },\r\n\r\n    /**\r\n     * Returns the row of the character to be read next.\r\n     * @return {int} The row of the character to be read next.\r\n     * @method getLine\r\n     */\r\n    getLine: function() {\r\n        return this._line;\r\n    },\r\n\r\n    /**\r\n     * Determines if you're at the end of the input.\r\n     * @return {Boolean} True if there's no more input, false otherwise.\r\n     * @method eof\r\n     */\r\n    eof: function() {\r\n        return this._cursor === this._input.length;\r\n    },\r\n\r\n    //-------------------------------------------------------------------------\r\n    // Basic reading\r\n    //-------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Reads the next character without advancing the cursor.\r\n     * @param {int} count How many characters to look ahead (default is 1).\r\n     * @return {String} The next character or null if there is no next character.\r\n     * @method peek\r\n     */\r\n    peek: function(count) {\r\n        var c = null;\r\n        count = typeof count === \"undefined\" ? 1 : count;\r\n\r\n        // if we're not at the end of the input...\r\n        if (this._cursor < this._input.length) {\r\n\r\n            // get character and increment cursor and column\r\n            c = this._input.charAt(this._cursor + count - 1);\r\n        }\r\n\r\n        return c;\r\n    },\r\n\r\n    /**\r\n     * Reads the next character from the input and adjusts the row and column\r\n     * accordingly.\r\n     * @return {String} The next character or null if there is no next character.\r\n     * @method read\r\n     */\r\n    read: function() {\r\n        var c = null;\r\n\r\n        // if we're not at the end of the input...\r\n        if (this._cursor < this._input.length) {\r\n\r\n            // if the last character was a newline, increment row count\r\n            // and reset column count\r\n            if (this._input.charAt(this._cursor) === \"\\n\") {\r\n                this._line++;\r\n                this._col=1;\r\n            } else {\r\n                this._col++;\r\n            }\r\n\r\n            // get character and increment cursor and column\r\n            c = this._input.charAt(this._cursor++);\r\n        }\r\n\r\n        return c;\r\n    },\r\n\r\n    //-------------------------------------------------------------------------\r\n    // Misc\r\n    //-------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Saves the current location so it can be returned to later.\r\n     * @method mark\r\n     * @return {void}\r\n     */\r\n    mark: function() {\r\n        this._bookmark = {\r\n            cursor: this._cursor,\r\n            line:   this._line,\r\n            col:    this._col\r\n        };\r\n    },\r\n\r\n    reset: function() {\r\n        if (this._bookmark) {\r\n            this._cursor = this._bookmark.cursor;\r\n            this._line = this._bookmark.line;\r\n            this._col = this._bookmark.col;\r\n            delete this._bookmark;\r\n        }\r\n    },\r\n\r\n    //-------------------------------------------------------------------------\r\n    // Advanced reading\r\n    //-------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Reads up to and including the given string. Throws an error if that\r\n     * string is not found.\r\n     * @param {String} pattern The string to read.\r\n     * @return {String} The string when it is found.\r\n     * @throws Error when the string pattern is not found.\r\n     * @method readTo\r\n     */\r\n    readTo: function(pattern) {\r\n\r\n        var buffer = \"\",\r\n            c;\r\n\r\n        /*\r\n         * First, buffer must be the same length as the pattern.\r\n         * Then, buffer must end with the pattern or else reach the\r\n         * end of the input.\r\n         */\r\n        while (buffer.length < pattern.length || buffer.lastIndexOf(pattern) !== buffer.length - pattern.length) {\r\n            c = this.read();\r\n            if (c) {\r\n                buffer += c;\r\n            } else {\r\n                throw new Error(\"Expected \\\"\" + pattern + \"\\\" at line \" + this._line  + \", col \" + this._col + \".\");\r\n            }\r\n        }\r\n\r\n        return buffer;\r\n\r\n    },\r\n\r\n    /**\r\n     * Reads characters while each character causes the given\r\n     * filter function to return true. The function is passed\r\n     * in each character and either returns true to continue\r\n     * reading or false to stop.\r\n     * @param {Function} filter The function to read on each character.\r\n     * @return {String} The string made up of all characters that passed the\r\n     *      filter check.\r\n     * @method readWhile\r\n     */\r\n    readWhile: function(filter) {\r\n\r\n        var buffer = \"\",\r\n            c = this.peek();\r\n\r\n        while (c !== null && filter(c)) {\r\n            buffer += this.read();\r\n            c = this.peek();\r\n        }\r\n\r\n        return buffer;\r\n\r\n    },\r\n\r\n    /**\r\n     * Reads characters that match either text or a regular expression and\r\n     * returns those characters. If a match is found, the row and column\r\n     * are adjusted; if no match is found, the reader's state is unchanged.\r\n     * reading or false to stop.\r\n     * @param {String|RegExp} matcher If a string, then the literal string\r\n     *      value is searched for. If a regular expression, then any string\r\n     *      matching the pattern is search for.\r\n     * @return {String} The string made up of all characters that matched or\r\n     *      null if there was no match.\r\n     * @method readMatch\r\n     */\r\n    readMatch: function(matcher) {\r\n\r\n        var source = this._input.substring(this._cursor),\r\n            value = null;\r\n\r\n        // if it's a string, just do a straight match\r\n        if (typeof matcher === \"string\") {\r\n            if (source.slice(0, matcher.length) === matcher) {\r\n                value = this.readCount(matcher.length);\r\n            }\r\n        } else if (matcher instanceof RegExp) {\r\n            if (matcher.test(source)) {\r\n                value = this.readCount(RegExp.lastMatch.length);\r\n            }\r\n        }\r\n\r\n        return value;\r\n    },\r\n\r\n\r\n    /**\r\n     * Reads a given number of characters. If the end of the input is reached,\r\n     * it reads only the remaining characters and does not throw an error.\r\n     * @param {int} count The number of characters to read.\r\n     * @return {String} The string made up the read characters.\r\n     * @method readCount\r\n     */\r\n    readCount: function(count) {\r\n        var buffer = \"\";\r\n\r\n        while (count--) {\r\n            buffer += this.read();\r\n        }\r\n\r\n        return buffer;\r\n    }\r\n\r\n};\r\n","/home/travis/build/npmtest/node-npmtest-parserlib/node_modules/parserlib/src/css/Validation.js":"\"use strict\";\r\n\r\n/* exported Validation */\r\n\r\nvar Matcher = require(\"./Matcher\");\r\nvar Properties = require(\"./Properties\");\r\nvar ValidationTypes = require(\"./ValidationTypes\");\r\nvar ValidationError = require(\"./ValidationError\");\r\nvar PropertyValueIterator = require(\"./PropertyValueIterator\");\r\n\r\nvar Validation = module.exports = {\r\n\r\n    validate: function(property, value) {\r\n\r\n        //normalize name\r\n        var name        = property.toString().toLowerCase(),\r\n            expression  = new PropertyValueIterator(value),\r\n            spec        = Properties[name],\r\n            part;\r\n\r\n        if (!spec) {\r\n            if (name.indexOf(\"-\") !== 0) {    //vendor prefixed are ok\r\n                throw new ValidationError(\"Unknown property '\" + property + \"'.\", property.line, property.col);\r\n            }\r\n        } else if (typeof spec !== \"number\") {\r\n\r\n            // All properties accept some CSS-wide values.\r\n            // https://drafts.csswg.org/css-values-3/#common-keywords\r\n            if (ValidationTypes.isAny(expression, \"inherit | initial | unset\")) {\r\n                if (expression.hasNext()) {\r\n                    part = expression.next();\r\n                    throw new ValidationError(\"Expected end of value but found '\" + part + \"'.\", part.line, part.col);\r\n                }\r\n                return;\r\n            }\r\n\r\n            // Property-specific validation.\r\n            this.singleProperty(spec, expression);\r\n\r\n        }\r\n\r\n    },\r\n\r\n    singleProperty: function(types, expression) {\r\n\r\n        var result      = false,\r\n            value       = expression.value,\r\n            part;\r\n\r\n        result = Matcher.parse(types).match(expression);\r\n\r\n        if (!result) {\r\n            if (expression.hasNext() && !expression.isFirst()) {\r\n                part = expression.peek();\r\n                throw new ValidationError(\"Expected end of value but found '\" + part + \"'.\", part.line, part.col);\r\n            } else {\r\n                throw new ValidationError(\"Expected (\" + ValidationTypes.describe(types) + \") but found '\" + value + \"'.\", value.line, value.col);\r\n            }\r\n        } else if (expression.hasNext()) {\r\n            part = expression.next();\r\n            throw new ValidationError(\"Expected end of value but found '\" + part + \"'.\", part.line, part.col);\r\n        }\r\n\r\n    }\r\n\r\n};\r\n","/home/travis/build/npmtest/node-npmtest-parserlib/node_modules/parserlib/src/css/Matcher.js":"\"use strict\";\r\n\r\nmodule.exports = Matcher;\r\n\r\nvar StringReader = require(\"../util/StringReader\");\r\nvar SyntaxError = require(\"../util/SyntaxError\");\r\n\r\n/**\r\n * This class implements a combinator library for matcher functions.\r\n * The combinators are described at:\r\n * https://developer.mozilla.org/en-US/docs/Web/CSS/Value_definition_syntax#Component_value_combinators\r\n */\r\nfunction Matcher(matchFunc, toString) {\r\n    this.match = function(expression) {\r\n        // Save/restore marks to ensure that failed matches always restore\r\n        // the original location in the expression.\r\n        var result;\r\n        expression.mark();\r\n        result = matchFunc(expression);\r\n        if (result) {\r\n            expression.drop();\r\n        } else {\r\n            expression.restore();\r\n        }\r\n        return result;\r\n    };\r\n    this.toString = typeof toString === \"function\" ? toString : function() {\r\n        return toString;\r\n    };\r\n}\r\n\r\n/** Precedence table of combinators. */\r\nMatcher.prec = {\r\n    MOD:    5,\r\n    SEQ:    4,\r\n    ANDAND: 3,\r\n    OROR:   2,\r\n    ALT:    1\r\n};\r\n\r\n/** Simple recursive-descent grammar to build matchers from strings. */\r\nMatcher.parse = function(str) {\r\n    var reader, eat, expr, oror, andand, seq, mod, term, result;\r\n    reader = new StringReader(str);\r\n    eat = function(matcher) {\r\n        var result = reader.readMatch(matcher);\r\n        if (result === null) {\r\n            throw new SyntaxError(\r\n                \"Expected \"+matcher, reader.getLine(), reader.getCol());\r\n        }\r\n        return result;\r\n    };\r\n    expr = function() {\r\n        // expr = oror (\" | \" oror)*\r\n        var m = [ oror() ];\r\n        while (reader.readMatch(\" | \") !== null) {\r\n            m.push(oror());\r\n        }\r\n        return m.length === 1 ? m[0] : Matcher.alt.apply(Matcher, m);\r\n    };\r\n    oror = function() {\r\n        // oror = andand ( \" || \" andand)*\r\n        var m = [ andand() ];\r\n        while (reader.readMatch(\" || \") !== null) {\r\n            m.push(andand());\r\n        }\r\n        return m.length === 1 ? m[0] : Matcher.oror.apply(Matcher, m);\r\n    };\r\n    andand = function() {\r\n        // andand = seq ( \" && \" seq)*\r\n        var m = [ seq() ];\r\n        while (reader.readMatch(\" && \") !== null) {\r\n            m.push(seq());\r\n        }\r\n        return m.length === 1 ? m[0] : Matcher.andand.apply(Matcher, m);\r\n    };\r\n    seq = function() {\r\n        // seq = mod ( \" \" mod)*\r\n        var m = [ mod() ];\r\n        while (reader.readMatch(/^ (?![&|\\]])/) !== null) {\r\n            m.push(mod());\r\n        }\r\n        return m.length === 1 ? m[0] : Matcher.seq.apply(Matcher, m);\r\n    };\r\n    mod = function() {\r\n        // mod = term ( \"?\" | \"*\" | \"+\" | \"#\" | \"{<num>,<num>}\" )?\r\n        var m = term();\r\n        if (reader.readMatch(\"?\") !== null) {\r\n            return m.question();\r\n        } else if (reader.readMatch(\"*\") !== null) {\r\n            return m.star();\r\n        } else if (reader.readMatch(\"+\") !== null) {\r\n            return m.plus();\r\n        } else if (reader.readMatch(\"#\") !== null) {\r\n            return m.hash();\r\n        } else if (reader.readMatch(/^\\{\\s*/) !== null) {\r\n            var min = eat(/^\\d+/);\r\n            eat(/^\\s*,\\s*/);\r\n            var max = eat(/^\\d+/);\r\n            eat(/^\\s*\\}/);\r\n            return m.braces(+min, +max);\r\n        }\r\n        return m;\r\n    };\r\n    term = function() {\r\n        // term = <nt> | literal | \"[ \" expression \" ]\"\r\n        if (reader.readMatch(\"[ \") !== null) {\r\n            var m = expr();\r\n            eat(\" ]\");\r\n            return m;\r\n        }\r\n        return Matcher.fromType(eat(/^[^ ?*+#{]+/));\r\n    };\r\n    result = expr();\r\n    if (!reader.eof()) {\r\n        throw new SyntaxError(\r\n            \"Expected end of string\", reader.getLine(), reader.getCol());\r\n    }\r\n    return result;\r\n};\r\n\r\n/**\r\n * Convert a string to a matcher (parsing simple alternations),\r\n * or do nothing if the argument is already a matcher.\r\n */\r\nMatcher.cast = function(m) {\r\n    if (m instanceof Matcher) {\r\n        return m;\r\n    }\r\n    return Matcher.parse(m);\r\n};\r\n\r\n/**\r\n * Create a matcher for a single type.\r\n */\r\nMatcher.fromType = function(type) {\r\n    // Late require of ValidationTypes to break a dependency cycle.\r\n    var ValidationTypes = require(\"./ValidationTypes\");\r\n    return new Matcher(function(expression) {\r\n        return expression.hasNext() && ValidationTypes.isType(expression, type);\r\n    }, type);\r\n};\r\n\r\n/**\r\n * Create a matcher for one or more juxtaposed words, which all must\r\n * occur, in the given order.\r\n */\r\nMatcher.seq = function() {\r\n    var ms = Array.prototype.slice.call(arguments).map(Matcher.cast);\r\n    if (ms.length === 1) {\r\n        return ms[0];\r\n    }\r\n    return new Matcher(function(expression) {\r\n        var i, result = true;\r\n        for (i = 0; result && i < ms.length; i++) {\r\n            result = ms[i].match(expression);\r\n        }\r\n        return result;\r\n    }, function(prec) {\r\n        var p = Matcher.prec.SEQ;\r\n        var s = ms.map(function(m) {\r\n            return m.toString(p);\r\n        }).join(\" \");\r\n        if (prec > p) {\r\n            s = \"[ \" + s + \" ]\";\r\n        }\r\n        return s;\r\n    });\r\n};\r\n\r\n/**\r\n * Create a matcher for one or more alternatives, where exactly one\r\n * must occur.\r\n */\r\nMatcher.alt = function() {\r\n    var ms = Array.prototype.slice.call(arguments).map(Matcher.cast);\r\n    if (ms.length === 1) {\r\n        return ms[0];\r\n    }\r\n    return new Matcher(function(expression) {\r\n        var i, result = false;\r\n        for (i = 0; !result && i < ms.length; i++) {\r\n            result = ms[i].match(expression);\r\n        }\r\n        return result;\r\n    }, function(prec) {\r\n        var p = Matcher.prec.ALT;\r\n        var s = ms.map(function(m) {\r\n            return m.toString(p);\r\n        }).join(\" | \");\r\n        if (prec > p) {\r\n            s = \"[ \" + s + \" ]\";\r\n        }\r\n        return s;\r\n    });\r\n};\r\n\r\n/**\r\n * Create a matcher for two or more options.  This implements the\r\n * double bar (||) and double ampersand (&&) operators, as well as\r\n * variants of && where some of the alternatives are optional.\r\n * This will backtrack through even successful matches to try to\r\n * maximize the number of items matched.\r\n */\r\nMatcher.many = function(required) {\r\n    var ms = Array.prototype.slice.call(arguments, 1).reduce(function(acc, v) {\r\n        if (v.expand) {\r\n            // Insert all of the options for the given complex rule as\r\n            // individual options.\r\n            var ValidationTypes = require(\"./ValidationTypes\");\r\n            acc.push.apply(acc, ValidationTypes.complex[v.expand].options);\r\n        } else {\r\n            acc.push(Matcher.cast(v));\r\n        }\r\n        return acc;\r\n    }, []);\r\n\r\n    if (required === true) {\r\n        required = ms.map(function() {\r\n            return true;\r\n        });\r\n    }\r\n\r\n    var result = new Matcher(function(expression) {\r\n        var seen = [], max = 0, pass = 0;\r\n        var success = function(matchCount) {\r\n            if (pass === 0) {\r\n                max = Math.max(matchCount, max);\r\n                return matchCount === ms.length;\r\n            } else {\r\n                return matchCount === max;\r\n            }\r\n        };\r\n        var tryMatch = function(matchCount) {\r\n            for (var i = 0; i < ms.length; i++) {\r\n                if (seen[i]) {\r\n                    continue;\r\n                }\r\n                expression.mark();\r\n                if (ms[i].match(expression)) {\r\n                    seen[i] = true;\r\n                    // Increase matchCount iff this was a required element\r\n                    // (or if all the elements are optional)\r\n                    if (tryMatch(matchCount + ((required === false || required[i]) ? 1 : 0))) {\r\n                        expression.drop();\r\n                        return true;\r\n                    }\r\n                    // Backtrack: try *not* matching using this rule, and\r\n                    // let's see if it leads to a better overall match.\r\n                    expression.restore();\r\n                    seen[i] = false;\r\n                } else {\r\n                    expression.drop();\r\n                }\r\n            }\r\n            return success(matchCount);\r\n        };\r\n        if (!tryMatch(0)) {\r\n            // Couldn't get a complete match, retrace our steps to make the\r\n            // match with the maximum # of required elements.\r\n            pass++;\r\n            tryMatch(0);\r\n        }\r\n\r\n        if (required === false) {\r\n            return max > 0;\r\n        }\r\n        // Use finer-grained specification of which matchers are required.\r\n        for (var i = 0; i < ms.length; i++) {\r\n            if (required[i] && !seen[i]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }, function(prec) {\r\n        var p = required === false ? Matcher.prec.OROR : Matcher.prec.ANDAND;\r\n        var s = ms.map(function(m, i) {\r\n            if (required !== false && !required[i]) {\r\n                return m.toString(Matcher.prec.MOD) + \"?\";\r\n            }\r\n            return m.toString(p);\r\n        }).join(required === false ? \" || \" : \" && \");\r\n        if (prec > p) {\r\n            s = \"[ \" + s + \" ]\";\r\n        }\r\n        return s;\r\n    });\r\n    result.options = ms;\r\n    return result;\r\n};\r\n\r\n/**\r\n * Create a matcher for two or more options, where all options are\r\n * mandatory but they may appear in any order.\r\n */\r\nMatcher.andand = function() {\r\n    var args = Array.prototype.slice.call(arguments);\r\n    args.unshift(true);\r\n    return Matcher.many.apply(Matcher, args);\r\n};\r\n\r\n/**\r\n * Create a matcher for two or more options, where options are\r\n * optional and may appear in any order, but at least one must be\r\n * present.\r\n */\r\nMatcher.oror = function() {\r\n    var args = Array.prototype.slice.call(arguments);\r\n    args.unshift(false);\r\n    return Matcher.many.apply(Matcher, args);\r\n};\r\n\r\n/** Instance methods on Matchers. */\r\nMatcher.prototype = {\r\n    constructor: Matcher,\r\n    // These are expected to be overridden in every instance.\r\n    match: function() { throw new Error(\"unimplemented\"); },\r\n    toString: function() { throw new Error(\"unimplemented\"); },\r\n    // This returns a standalone function to do the matching.\r\n    func: function() { return this.match.bind(this); },\r\n    // Basic combinators\r\n    then: function(m) { return Matcher.seq(this, m); },\r\n    or: function(m) { return Matcher.alt(this, m); },\r\n    andand: function(m) { return Matcher.many(true, this, m); },\r\n    oror: function(m) { return Matcher.many(false, this, m); },\r\n    // Component value multipliers\r\n    star: function() { return this.braces(0, Infinity, \"*\"); },\r\n    plus: function() { return this.braces(1, Infinity, \"+\"); },\r\n    question: function() { return this.braces(0, 1, \"?\"); },\r\n    hash: function() {\r\n        return this.braces(1, Infinity, \"#\", Matcher.cast(\",\"));\r\n    },\r\n    braces: function(min, max, marker, optSep) {\r\n        var m1 = this, m2 = optSep ? optSep.then(this) : this;\r\n        if (!marker) {\r\n            marker = \"{\" + min + \",\" + max + \"}\";\r\n        }\r\n        return new Matcher(function(expression) {\r\n            var result = true, i;\r\n            for (i = 0; i < max; i++) {\r\n                if (i > 0 && optSep) {\r\n                    result = m2.match(expression);\r\n                } else {\r\n                    result = m1.match(expression);\r\n                }\r\n                if (!result) {\r\n                    break;\r\n                }\r\n            }\r\n            return i >= min;\r\n        }, function() {\r\n            return m1.toString(Matcher.prec.MOD) + marker;\r\n        });\r\n    }\r\n};\r\n","/home/travis/build/npmtest/node-npmtest-parserlib/node_modules/parserlib/src/css/Properties.js":"\"use strict\";\r\n\r\n/* exported Properties */\r\n\r\nvar Properties = module.exports = {\r\n    __proto__: null,\r\n\r\n    //A\r\n    \"align-items\"                   : \"flex-start | flex-end | center | baseline | stretch\",\r\n    \"align-content\"                 : \"flex-start | flex-end | center | space-between | space-around | stretch\",\r\n    \"align-self\"                    : \"auto | flex-start | flex-end | center | baseline | stretch\",\r\n    \"all\"                           : \"initial | inherit | unset\",\r\n    \"-webkit-align-items\"           : \"flex-start | flex-end | center | baseline | stretch\",\r\n    \"-webkit-align-content\"         : \"flex-start | flex-end | center | space-between | space-around | stretch\",\r\n    \"-webkit-align-self\"            : \"auto | flex-start | flex-end | center | baseline | stretch\",\r\n    \"alignment-adjust\"              : \"auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical | <percentage> | <length>\",\r\n    \"alignment-baseline\"            : \"auto | baseline | use-script | before-edge | text-before-edge | after-edge | text-after-edge | central | middle | ideographic | alphabetic | hanging | mathematical\",\r\n    \"animation\"                     : 1,\r\n    \"animation-delay\"               : \"<time>#\",\r\n    \"animation-direction\"           : \"<single-animation-direction>#\",\r\n    \"animation-duration\"            : \"<time>#\",\r\n    \"animation-fill-mode\"           : \"[ none | forwards | backwards | both ]#\",\r\n    \"animation-iteration-count\"     : \"[ <number> | infinite ]#\",\r\n    \"animation-name\"                : \"[ none | <single-animation-name> ]#\",\r\n    \"animation-play-state\"          : \"[ running | paused ]#\",\r\n    \"animation-timing-function\"     : 1,\r\n\r\n    //vendor prefixed\r\n    \"-moz-animation-delay\"               : \"<time>#\",\r\n    \"-moz-animation-direction\"           : \"[ normal | alternate ]#\",\r\n    \"-moz-animation-duration\"            : \"<time>#\",\r\n    \"-moz-animation-iteration-count\"     : \"[ <number> | infinite ]#\",\r\n    \"-moz-animation-name\"                : \"[ none | <single-animation-name> ]#\",\r\n    \"-moz-animation-play-state\"          : \"[ running | paused ]#\",\r\n\r\n    \"-ms-animation-delay\"               : \"<time>#\",\r\n    \"-ms-animation-direction\"           : \"[ normal | alternate ]#\",\r\n    \"-ms-animation-duration\"            : \"<time>#\",\r\n    \"-ms-animation-iteration-count\"     : \"[ <number> | infinite ]#\",\r\n    \"-ms-animation-name\"                : \"[ none | <single-animation-name> ]#\",\r\n    \"-ms-animation-play-state\"          : \"[ running | paused ]#\",\r\n\r\n    \"-webkit-animation-delay\"               : \"<time>#\",\r\n    \"-webkit-animation-direction\"           : \"[ normal | alternate ]#\",\r\n    \"-webkit-animation-duration\"            : \"<time>#\",\r\n    \"-webkit-animation-fill-mode\"           : \"[ none | forwards | backwards | both ]#\",\r\n    \"-webkit-animation-iteration-count\"     : \"[ <number> | infinite ]#\",\r\n    \"-webkit-animation-name\"                : \"[ none | <single-animation-name> ]#\",\r\n    \"-webkit-animation-play-state\"          : \"[ running | paused ]#\",\r\n\r\n    \"-o-animation-delay\"               : \"<time>#\",\r\n    \"-o-animation-direction\"           : \"[ normal | alternate ]#\",\r\n    \"-o-animation-duration\"            : \"<time>#\",\r\n    \"-o-animation-iteration-count\"     : \"[ <number> | infinite ]#\",\r\n    \"-o-animation-name\"                : \"[ none | <single-animation-name> ]#\",\r\n    \"-o-animation-play-state\"          : \"[ running | paused ]#\",\r\n\r\n    \"appearance\"                    : \"none | auto\",\r\n    \"-moz-appearance\"               : \"none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized\",\r\n    \"-ms-appearance\"                : \"none | icon | window | desktop | workspace | document | tooltip | dialog | button | push-button | hyperlink | radio | radio-button | checkbox | menu-item | tab | menu | menubar | pull-down-menu | pop-up-menu | list-menu | radio-group | checkbox-group | outline-tree | range | field | combo-box | signature | password | normal\",\r\n    \"-webkit-appearance\"            : \"none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox\t| listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button\t| media-seek-forward-button\t| media-slider | media-sliderthumb | menulist\t| menulist-button\t| menulist-text\t| menulist-textfield | push-button\t| radio\t| searchfield\t| searchfield-cancel-button\t| searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical\t| square-button\t| textarea\t| textfield\t| scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical\",\r\n    \"-o-appearance\"                 : \"none | window | desktop | workspace | document | tooltip | dialog | button | push-button | hyperlink | radio | radio-button | checkbox | menu-item | tab | menu | menubar | pull-down-menu | pop-up-menu | list-menu | radio-group | checkbox-group | outline-tree | range | field | combo-box | signature | password | normal\",\r\n\r\n    \"azimuth\"                       : \"<azimuth>\",\r\n\r\n    //B\r\n    \"backface-visibility\"           : \"visible | hidden\",\r\n    \"background\"                    : 1,\r\n    \"background-attachment\"         : \"<attachment>#\",\r\n    \"background-clip\"               : \"<box>#\",\r\n    \"background-color\"              : \"<color>\",\r\n    \"background-image\"              : \"<bg-image>#\",\r\n    \"background-origin\"             : \"<box>#\",\r\n    \"background-position\"           : \"<bg-position>\",\r\n    \"background-repeat\"             : \"<repeat-style>#\",\r\n    \"background-size\"               : \"<bg-size>#\",\r\n    \"baseline-shift\"                : \"baseline | sub | super | <percentage> | <length>\",\r\n    \"behavior\"                      : 1,\r\n    \"binding\"                       : 1,\r\n    \"bleed\"                         : \"<length>\",\r\n    \"bookmark-label\"                : \"<content> | <attr> | <string>\",\r\n    \"bookmark-level\"                : \"none | <integer>\",\r\n    \"bookmark-state\"                : \"open | closed\",\r\n    \"bookmark-target\"               : \"none | <uri> | <attr>\",\r\n    \"border\"                        : \"<border-width> || <border-style> || <color>\",\r\n    \"border-bottom\"                 : \"<border-width> || <border-style> || <color>\",\r\n    \"border-bottom-color\"           : \"<color>\",\r\n    \"border-bottom-left-radius\"     :  \"<x-one-radius>\",\r\n    \"border-bottom-right-radius\"    :  \"<x-one-radius>\",\r\n    \"border-bottom-style\"           : \"<border-style>\",\r\n    \"border-bottom-width\"           : \"<border-width>\",\r\n    \"border-collapse\"               : \"collapse | separate\",\r\n    \"border-color\"                  : \"<color>{1,4}\",\r\n    \"border-image\"                  : 1,\r\n    \"border-image-outset\"           : \"[ <length> | <number> ]{1,4}\",\r\n    \"border-image-repeat\"           : \"[ stretch | repeat | round ]{1,2}\",\r\n    \"border-image-slice\"            : \"<border-image-slice>\",\r\n    \"border-image-source\"           : \"<image> | none\",\r\n    \"border-image-width\"            : \"[ <length> | <percentage> | <number> | auto ]{1,4}\",\r\n    \"border-left\"                   : \"<border-width> || <border-style> || <color>\",\r\n    \"border-left-color\"             : \"<color>\",\r\n    \"border-left-style\"             : \"<border-style>\",\r\n    \"border-left-width\"             : \"<border-width>\",\r\n    \"border-radius\"                 : \"<border-radius>\",\r\n    \"border-right\"                  : \"<border-width> || <border-style> || <color>\",\r\n    \"border-right-color\"            : \"<color>\",\r\n    \"border-right-style\"            : \"<border-style>\",\r\n    \"border-right-width\"            : \"<border-width>\",\r\n    \"border-spacing\"                : \"<length>{1,2}\",\r\n    \"border-style\"                  : \"<border-style>{1,4}\",\r\n    \"border-top\"                    : \"<border-width> || <border-style> || <color>\",\r\n    \"border-top-color\"              : \"<color>\",\r\n    \"border-top-left-radius\"        : \"<x-one-radius>\",\r\n    \"border-top-right-radius\"       : \"<x-one-radius>\",\r\n    \"border-top-style\"              : \"<border-style>\",\r\n    \"border-top-width\"              : \"<border-width>\",\r\n    \"border-width\"                  : \"<border-width>{1,4}\",\r\n    \"bottom\"                        : \"<margin-width>\",\r\n    \"-moz-box-align\"                : \"start | end | center | baseline | stretch\",\r\n    \"-moz-box-decoration-break\"     : \"slice | clone\",\r\n    \"-moz-box-direction\"            : \"normal | reverse\",\r\n    \"-moz-box-flex\"                 : \"<number>\",\r\n    \"-moz-box-flex-group\"           : \"<integer>\",\r\n    \"-moz-box-lines\"                : \"single | multiple\",\r\n    \"-moz-box-ordinal-group\"        : \"<integer>\",\r\n    \"-moz-box-orient\"               : \"horizontal | vertical | inline-axis | block-axis\",\r\n    \"-moz-box-pack\"                 : \"start | end | center | justify\",\r\n    \"-o-box-decoration-break\"       : \"slice | clone\",\r\n    \"-webkit-box-align\"             : \"start | end | center | baseline | stretch\",\r\n    \"-webkit-box-decoration-break\"  : \"slice | clone\",\r\n    \"-webkit-box-direction\"         : \"normal | reverse\",\r\n    \"-webkit-box-flex\"              : \"<number>\",\r\n    \"-webkit-box-flex-group\"        : \"<integer>\",\r\n    \"-webkit-box-lines\"             : \"single | multiple\",\r\n    \"-webkit-box-ordinal-group\"     : \"<integer>\",\r\n    \"-webkit-box-orient\"            : \"horizontal | vertical | inline-axis | block-axis\",\r\n    \"-webkit-box-pack\"              : \"start | end | center | justify\",\r\n    \"box-decoration-break\"          : \"slice | clone\",\r\n    \"box-shadow\"                    : \"<box-shadow>\",\r\n    \"box-sizing\"                    : \"content-box | border-box\",\r\n    \"break-after\"                   : \"auto | always | avoid | left | right | page | column | avoid-page | avoid-column\",\r\n    \"break-before\"                  : \"auto | always | avoid | left | right | page | column | avoid-page | avoid-column\",\r\n    \"break-inside\"                  : \"auto | avoid | avoid-page | avoid-column\",\r\n\r\n    //C\r\n    \"caption-side\"                  : \"top | bottom\",\r\n    \"clear\"                         : \"none | right | left | both\",\r\n    \"clip\"                          : \"<shape> | auto\",\r\n    \"-webkit-clip-path\"             : \"<clip-source> | <clip-path> | none\",\r\n    \"clip-path\"                     : \"<clip-source> | <clip-path> | none\",\r\n    \"clip-rule\"                     : \"nonzero | evenodd\",\r\n    \"color\"                         : \"<color>\",\r\n    \"color-interpolation\"           : \"auto | sRGB | linearRGB\",\r\n    \"color-interpolation-filters\"   : \"auto | sRGB | linearRGB\",\r\n    \"color-profile\"                 : 1,\r\n    \"color-rendering\"               : \"auto | optimizeSpeed | optimizeQuality\",\r\n    \"column-count\"                  : \"<integer> | auto\",                      //https://www.w3.org/TR/css3-multicol/\r\n    \"column-fill\"                   : \"auto | balance\",\r\n    \"column-gap\"                    : \"<length> | normal\",\r\n    \"column-rule\"                   : \"<border-width> || <border-style> || <color>\",\r\n    \"column-rule-color\"             : \"<color>\",\r\n    \"column-rule-style\"             : \"<border-style>\",\r\n    \"column-rule-width\"             : \"<border-width>\",\r\n    \"column-span\"                   : \"none | all\",\r\n    \"column-width\"                  : \"<length> | auto\",\r\n    \"columns\"                       : 1,\r\n    \"content\"                       : 1,\r\n    \"counter-increment\"             : 1,\r\n    \"counter-reset\"                 : 1,\r\n    \"crop\"                          : \"<shape> | auto\",\r\n    \"cue\"                           : \"cue-after | cue-before\",\r\n    \"cue-after\"                     : 1,\r\n    \"cue-before\"                    : 1,\r\n    \"cursor\"                        : 1,\r\n\r\n    //D\r\n    \"direction\"                     : \"ltr | rtl\",\r\n    \"display\"                       : \"inline | block | list-item | inline-block | table | inline-table | table-row-group | table-header-group | table-footer-group | table-row | table-column-group | table-column | table-cell | table-caption | grid | inline-grid | run-in | ruby | ruby-base | ruby-text | ruby-base-container | ruby-text-container | contents | none | -moz-box | -moz-inline-block | -moz-inline-box | -moz-inline-grid | -moz-inline-stack | -moz-inline-table | -moz-grid | -moz-grid-group | -moz-grid-line | -moz-groupbox | -moz-deck | -moz-popup | -moz-stack | -moz-marker | -webkit-box | -webkit-inline-box | -ms-flexbox | -ms-inline-flexbox | flex | -webkit-flex | inline-flex | -webkit-inline-flex\",\r\n    \"dominant-baseline\"             : \"auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge\",\r\n    \"drop-initial-after-adjust\"     : \"central | middle | after-edge | text-after-edge | ideographic | alphabetic | mathematical | <percentage> | <length>\",\r\n    \"drop-initial-after-align\"      : \"baseline | use-script | before-edge | text-before-edge | after-edge | text-after-edge | central | middle | ideographic | alphabetic | hanging | mathematical\",\r\n    \"drop-initial-before-adjust\"    : \"before-edge | text-before-edge | central | middle | hanging | mathematical | <percentage> | <length>\",\r\n    \"drop-initial-before-align\"     : \"caps-height | baseline | use-script | before-edge | text-before-edge | after-edge | text-after-edge | central | middle | ideographic | alphabetic | hanging | mathematical\",\r\n    \"drop-initial-size\"             : \"auto | line | <length> | <percentage>\",\r\n    \"drop-initial-value\"            : \"<integer>\",\r\n\r\n    //E\r\n    \"elevation\"                     : \"<angle> | below | level | above | higher | lower\",\r\n    \"empty-cells\"                   : \"show | hide\",\r\n    \"enable-background\"             : 1,\r\n\r\n    //F\r\n    \"fill\"                          : \"<paint>\",\r\n    \"fill-opacity\"                  : \"<opacity-value>\",\r\n    \"fill-rule\"                     : \"nonzero | evenodd\",\r\n    \"filter\"                        : \"<filter-function-list> | none\",\r\n    \"fit\"                           : \"fill | hidden | meet | slice\",\r\n    \"fit-position\"                  : 1,\r\n    \"flex\"                          : \"<flex>\",\r\n    \"flex-basis\"                    : \"<width>\",\r\n    \"flex-direction\"                : \"row | row-reverse | column | column-reverse\",\r\n    \"flex-flow\"                     : \"<flex-direction> || <flex-wrap>\",\r\n    \"flex-grow\"                     : \"<number>\",\r\n    \"flex-shrink\"                   : \"<number>\",\r\n    \"flex-wrap\"                     : \"nowrap | wrap | wrap-reverse\",\r\n    \"-webkit-flex\"                  : \"<flex>\",\r\n    \"-webkit-flex-basis\"            : \"<width>\",\r\n    \"-webkit-flex-direction\"        : \"row | row-reverse | column | column-reverse\",\r\n    \"-webkit-flex-flow\"             : \"<flex-direction> || <flex-wrap>\",\r\n    \"-webkit-flex-grow\"             : \"<number>\",\r\n    \"-webkit-flex-shrink\"           : \"<number>\",\r\n    \"-webkit-flex-wrap\"             : \"nowrap | wrap | wrap-reverse\",\r\n    \"-ms-flex\"                      : \"<flex>\",\r\n    \"-ms-flex-align\"                : \"start | end | center | stretch | baseline\",\r\n    \"-ms-flex-direction\"            : \"row | row-reverse | column | column-reverse\",\r\n    \"-ms-flex-order\"                : \"<number>\",\r\n    \"-ms-flex-pack\"                 : \"start | end | center | justify\",\r\n    \"-ms-flex-wrap\"                 : \"nowrap | wrap | wrap-reverse\",\r\n    \"float\"                         : \"left | right | none\",\r\n    \"float-offset\"                  : 1,\r\n    \"flood-color\"                   : 1,\r\n    \"flood-opacity\"                 : \"<opacity-value>\",\r\n    \"font\"                          : \"<font-shorthand> | caption | icon | menu | message-box | small-caption | status-bar\",\r\n    \"font-family\"                   : \"<font-family>\",\r\n    \"font-feature-settings\"         : \"<feature-tag-value> | normal\",\r\n    \"font-kerning\"                  : \"auto | normal | none\",\r\n    \"font-size\"                     : \"<font-size>\",\r\n    \"font-size-adjust\"              : \"<number> | none\",\r\n    \"font-stretch\"                  : \"<font-stretch>\",\r\n    \"font-style\"                    : \"<font-style>\",\r\n    \"font-variant\"                  : \"<font-variant> | normal | none\",\r\n    \"font-variant-alternates\"       : \"<font-variant-alternates> | normal\",\r\n    \"font-variant-caps\"             : \"<font-variant-caps> | normal\",\r\n    \"font-variant-east-asian\"       : \"<font-variant-east-asian> | normal\",\r\n    \"font-variant-ligatures\"        : \"<font-variant-ligatures> | normal | none\",\r\n    \"font-variant-numeric\"          : \"<font-variant-numeric> | normal\",\r\n    \"font-variant-position\"         : \"normal | sub | super\",\r\n    \"font-weight\"                   : \"<font-weight>\",\r\n\r\n    //G\r\n    \"glyph-orientation-horizontal\"  : \"<glyph-angle>\",\r\n    \"glyph-orientation-vertical\"    : \"auto | <glyph-angle>\",\r\n    \"grid\"                          : 1,\r\n    \"grid-area\"                     : 1,\r\n    \"grid-auto-columns\"             : 1,\r\n    \"grid-auto-flow\"                : 1,\r\n    \"grid-auto-position\"            : 1,\r\n    \"grid-auto-rows\"                : 1,\r\n    \"grid-cell-stacking\"            : \"columns | rows | layer\",\r\n    \"grid-column\"                   : 1,\r\n    \"grid-columns\"                  : 1,\r\n    \"grid-column-align\"             : \"start | end | center | stretch\",\r\n    \"grid-column-sizing\"            : 1,\r\n    \"grid-column-start\"             : 1,\r\n    \"grid-column-end\"               : 1,\r\n    \"grid-column-span\"              : \"<integer>\",\r\n    \"grid-flow\"                     : \"none | rows | columns\",\r\n    \"grid-layer\"                    : \"<integer>\",\r\n    \"grid-row\"                      : 1,\r\n    \"grid-rows\"                     : 1,\r\n    \"grid-row-align\"                : \"start | end | center | stretch\",\r\n    \"grid-row-start\"                : 1,\r\n    \"grid-row-end\"                  : 1,\r\n    \"grid-row-span\"                 : \"<integer>\",\r\n    \"grid-row-sizing\"               : 1,\r\n    \"grid-template\"                 : 1,\r\n    \"grid-template-areas\"           : 1,\r\n    \"grid-template-columns\"         : 1,\r\n    \"grid-template-rows\"            : 1,\r\n\r\n    //H\r\n    \"hanging-punctuation\"           : 1,\r\n    \"height\"                        : \"<margin-width> | <content-sizing>\",\r\n    \"hyphenate-after\"               : \"<integer> | auto\",\r\n    \"hyphenate-before\"              : \"<integer> | auto\",\r\n    \"hyphenate-character\"           : \"<string> | auto\",\r\n    \"hyphenate-lines\"               : \"no-limit | <integer>\",\r\n    \"hyphenate-resource\"            : 1,\r\n    \"hyphens\"                       : \"none | manual | auto\",\r\n\r\n    //I\r\n    \"icon\"                          : 1,\r\n    \"image-orientation\"             : \"angle | auto\",\r\n    \"image-rendering\"               : \"auto | optimizeSpeed | optimizeQuality\",\r\n    \"image-resolution\"              : 1,\r\n    \"ime-mode\"                      : \"auto | normal | active | inactive | disabled\",\r\n    \"inline-box-align\"              : \"last | <integer>\",\r\n\r\n    //J\r\n    \"justify-content\"               : \"flex-start | flex-end | center | space-between | space-around\",\r\n    \"-webkit-justify-content\"       : \"flex-start | flex-end | center | space-between | space-around\",\r\n\r\n    //K\r\n    \"kerning\"                       : \"auto | <length>\",\r\n\r\n    //L\r\n    \"left\"                          : \"<margin-width>\",\r\n    \"letter-spacing\"                : \"<length> | normal\",\r\n    \"line-height\"                   : \"<line-height>\",\r\n    \"line-break\"                    : \"auto | loose | normal | strict\",\r\n    \"line-stacking\"                 : 1,\r\n    \"line-stacking-ruby\"            : \"exclude-ruby | include-ruby\",\r\n    \"line-stacking-shift\"           : \"consider-shifts | disregard-shifts\",\r\n    \"line-stacking-strategy\"        : \"inline-line-height | block-line-height | max-height | grid-height\",\r\n    \"list-style\"                    : 1,\r\n    \"list-style-image\"              : \"<uri> | none\",\r\n    \"list-style-position\"           : \"inside | outside\",\r\n    \"list-style-type\"               : \"disc | circle | square | decimal | decimal-leading-zero | lower-roman | upper-roman | lower-greek | lower-latin | upper-latin | armenian | georgian | lower-alpha | upper-alpha | none\",\r\n\r\n    //M\r\n    \"margin\"                        : \"<margin-width>{1,4}\",\r\n    \"margin-bottom\"                 : \"<margin-width>\",\r\n    \"margin-left\"                   : \"<margin-width>\",\r\n    \"margin-right\"                  : \"<margin-width>\",\r\n    \"margin-top\"                    : \"<margin-width>\",\r\n    \"mark\"                          : 1,\r\n    \"mark-after\"                    : 1,\r\n    \"mark-before\"                   : 1,\r\n    \"marker\"                        : 1,\r\n    \"marker-end\"                    : 1,\r\n    \"marker-mid\"                    : 1,\r\n    \"marker-start\"                  : 1,\r\n    \"marks\"                         : 1,\r\n    \"marquee-direction\"             : 1,\r\n    \"marquee-play-count\"            : 1,\r\n    \"marquee-speed\"                 : 1,\r\n    \"marquee-style\"                 : 1,\r\n    \"mask\"                          : 1,\r\n    \"max-height\"                    : \"<length> | <percentage> | <content-sizing> | none\",\r\n    \"max-width\"                     : \"<length> | <percentage> | <content-sizing> | none\",\r\n    \"min-height\"                    : \"<length> | <percentage> | <content-sizing> | contain-floats | -moz-contain-floats | -webkit-contain-floats\",\r\n    \"min-width\"                     : \"<length> | <percentage> | <content-sizing> | contain-floats | -moz-contain-floats | -webkit-contain-floats\",\r\n    \"move-to\"                       : 1,\r\n\r\n    //N\r\n    \"nav-down\"                      : 1,\r\n    \"nav-index\"                     : 1,\r\n    \"nav-left\"                      : 1,\r\n    \"nav-right\"                     : 1,\r\n    \"nav-up\"                        : 1,\r\n\r\n    //O\r\n    \"object-fit\"                    : \"fill | contain | cover | none | scale-down\",\r\n    \"object-position\"               : \"<position>\",\r\n    \"opacity\"                       : \"<opacity-value>\",\r\n    \"order\"                         : \"<integer>\",\r\n    \"-webkit-order\"                 : \"<integer>\",\r\n    \"orphans\"                       : \"<integer>\",\r\n    \"outline\"                       : 1,\r\n    \"outline-color\"                 : \"<color> | invert\",\r\n    \"outline-offset\"                : 1,\r\n    \"outline-style\"                 : \"<border-style>\",\r\n    \"outline-width\"                 : \"<border-width>\",\r\n    \"overflow\"                      : \"visible | hidden | scroll | auto\",\r\n    \"overflow-style\"                : 1,\r\n    \"overflow-wrap\"                 : \"normal | break-word\",\r\n    \"overflow-x\"                    : 1,\r\n    \"overflow-y\"                    : 1,\r\n\r\n    //P\r\n    \"padding\"                       : \"<padding-width>{1,4}\",\r\n    \"padding-bottom\"                : \"<padding-width>\",\r\n    \"padding-left\"                  : \"<padding-width>\",\r\n    \"padding-right\"                 : \"<padding-width>\",\r\n    \"padding-top\"                   : \"<padding-width>\",\r\n    \"page\"                          : 1,\r\n    \"page-break-after\"              : \"auto | always | avoid | left | right\",\r\n    \"page-break-before\"             : \"auto | always | avoid | left | right\",\r\n    \"page-break-inside\"             : \"auto | avoid\",\r\n    \"page-policy\"                   : 1,\r\n    \"pause\"                         : 1,\r\n    \"pause-after\"                   : 1,\r\n    \"pause-before\"                  : 1,\r\n    \"perspective\"                   : 1,\r\n    \"perspective-origin\"            : 1,\r\n    \"phonemes\"                      : 1,\r\n    \"pitch\"                         : 1,\r\n    \"pitch-range\"                   : 1,\r\n    \"play-during\"                   : 1,\r\n    \"pointer-events\"                : \"auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all\",\r\n    \"position\"                      : \"static | relative | absolute | fixed\",\r\n    \"presentation-level\"            : 1,\r\n    \"punctuation-trim\"              : 1,\r\n\r\n    //Q\r\n    \"quotes\"                        : 1,\r\n\r\n    //R\r\n    \"rendering-intent\"              : 1,\r\n    \"resize\"                        : 1,\r\n    \"rest\"                          : 1,\r\n    \"rest-after\"                    : 1,\r\n    \"rest-before\"                   : 1,\r\n    \"richness\"                      : 1,\r\n    \"right\"                         : \"<margin-width>\",\r\n    \"rotation\"                      : 1,\r\n    \"rotation-point\"                : 1,\r\n    \"ruby-align\"                    : 1,\r\n    \"ruby-overhang\"                 : 1,\r\n    \"ruby-position\"                 : 1,\r\n    \"ruby-span\"                     : 1,\r\n\r\n    //S\r\n    \"shape-rendering\"               : \"auto | optimizeSpeed | crispEdges | geometricPrecision\",\r\n    \"size\"                          : 1,\r\n    \"speak\"                         : \"normal | none | spell-out\",\r\n    \"speak-header\"                  : \"once | always\",\r\n    \"speak-numeral\"                 : \"digits | continuous\",\r\n    \"speak-punctuation\"             : \"code | none\",\r\n    \"speech-rate\"                   : 1,\r\n    \"src\"                           : 1,\r\n    \"stop-color\"                    : 1,\r\n    \"stop-opacity\"                  : \"<opacity-value>\",\r\n    \"stress\"                        : 1,\r\n    \"string-set\"                    : 1,\r\n    \"stroke\"                        : \"<paint>\",\r\n    \"stroke-dasharray\"              : \"none | <dasharray>\",\r\n    \"stroke-dashoffset\"             : \"<percentage> | <length>\",\r\n    \"stroke-linecap\"                : \"butt | round | square\",\r\n    \"stroke-linejoin\"               : \"miter | round | bevel\",\r\n    \"stroke-miterlimit\"             : \"<miterlimit>\",\r\n    \"stroke-opacity\"                : \"<opacity-value>\",\r\n    \"stroke-width\"                  : \"<percentage> | <length>\",\r\n\r\n    \"table-layout\"                  : \"auto | fixed\",\r\n    \"tab-size\"                      : \"<integer> | <length>\",\r\n    \"target\"                        : 1,\r\n    \"target-name\"                   : 1,\r\n    \"target-new\"                    : 1,\r\n    \"target-position\"               : 1,\r\n    \"text-align\"                    : \"left | right | center | justify | match-parent | start | end\",\r\n    \"text-align-last\"               : 1,\r\n    \"text-anchor\"                   : \"start | middle | end\",\r\n    \"text-decoration\"               : \"<text-decoration-line> || <text-decoration-style> || <text-decoration-color>\",\r\n    \"text-decoration-color\"         : \"<text-decoration-color>\",\r\n    \"text-decoration-line\"          : \"<text-decoration-line>\",\r\n    \"text-decoration-style\"         : \"<text-decoration-style>\",\r\n    \"text-emphasis\"                 : 1,\r\n    \"text-height\"                   : 1,\r\n    \"text-indent\"                   : \"<length> | <percentage>\",\r\n    \"text-justify\"                  : \"auto | none | inter-word | inter-ideograph | inter-cluster | distribute | kashida\",\r\n    \"text-outline\"                  : 1,\r\n    \"text-overflow\"                 : 1,\r\n    \"text-rendering\"                : \"auto | optimizeSpeed | optimizeLegibility | geometricPrecision\",\r\n    \"text-shadow\"                   : 1,\r\n    \"text-transform\"                : \"capitalize | uppercase | lowercase | none\",\r\n    \"text-wrap\"                     : \"normal | none | avoid\",\r\n    \"top\"                           : \"<margin-width>\",\r\n    \"-ms-touch-action\"              : \"auto | none | pan-x | pan-y | pan-left | pan-right | pan-up | pan-down | manipulation\",\r\n    \"touch-action\"                  : \"auto | none | pan-x | pan-y | pan-left | pan-right | pan-up | pan-down | manipulation\",\r\n    \"transform\"                     : 1,\r\n    \"transform-origin\"              : 1,\r\n    \"transform-style\"               : 1,\r\n    \"transition\"                    : 1,\r\n    \"transition-delay\"              : 1,\r\n    \"transition-duration\"           : 1,\r\n    \"transition-property\"           : 1,\r\n    \"transition-timing-function\"    : 1,\r\n\r\n    //U\r\n    \"unicode-bidi\"                  : \"normal | embed | isolate | bidi-override | isolate-override | plaintext\",\r\n    \"user-modify\"                   : \"read-only | read-write | write-only\",\r\n    \"user-select\"                   : \"none | text | toggle | element | elements | all\",\r\n\r\n    //V\r\n    \"vertical-align\"                : \"auto | use-script | baseline | sub | super | top | text-top | central | middle | bottom | text-bottom | <percentage> | <length>\",\r\n    \"visibility\"                    : \"visible | hidden | collapse\",\r\n    \"voice-balance\"                 : 1,\r\n    \"voice-duration\"                : 1,\r\n    \"voice-family\"                  : 1,\r\n    \"voice-pitch\"                   : 1,\r\n    \"voice-pitch-range\"             : 1,\r\n    \"voice-rate\"                    : 1,\r\n    \"voice-stress\"                  : 1,\r\n    \"voice-volume\"                  : 1,\r\n    \"volume\"                        : 1,\r\n\r\n    //W\r\n    \"white-space\"                   : \"normal | pre | nowrap | pre-wrap | pre-line | -pre-wrap | -o-pre-wrap | -moz-pre-wrap | -hp-pre-wrap\",   // https://perishablepress.com/wrapping-content/\r\n    \"white-space-collapse\"          : 1,\r\n    \"widows\"                        : \"<integer>\",\r\n    \"width\"                         : \"<length> | <percentage> | <content-sizing> | auto\",\r\n    \"will-change\"                   : \"<will-change>\",\r\n    \"word-break\"                    : \"normal | keep-all | break-all\",\r\n    \"word-spacing\"                  : \"<length> | normal\",\r\n    \"word-wrap\"                     : \"normal | break-word\",\r\n    \"writing-mode\"                  : \"horizontal-tb | vertical-rl | vertical-lr | lr-tb | rl-tb | tb-rl | bt-rl | tb-lr | bt-lr | lr-bt | rl-bt | lr | rl | tb\",\r\n\r\n    //Z\r\n    \"z-index\"                       : \"<integer> | auto\",\r\n    \"zoom\"                          : \"<number> | <percentage> | normal\"\r\n};\r\n","/home/travis/build/npmtest/node-npmtest-parserlib/node_modules/parserlib/src/css/ValidationTypes.js":"\"use strict\";\r\n\r\nvar ValidationTypes = module.exports;\r\n\r\nvar Matcher = require(\"./Matcher\");\r\n\r\nfunction copy(to, from) {\r\n    Object.keys(from).forEach(function(prop) {\r\n        to[prop] = from[prop];\r\n    });\r\n}\r\ncopy(ValidationTypes, {\r\n\r\n    isLiteral: function (part, literals) {\r\n        var text = part.text.toString().toLowerCase(),\r\n            args = literals.split(\" | \"),\r\n            i, len, found = false;\r\n\r\n        for (i=0, len=args.length; i < len && !found; i++) {\r\n            if (args[i].charAt(0) === \"<\") {\r\n                found = this.simple[args[i]](part);\r\n            } else if (args[i].slice(-2) === \"()\") {\r\n                found = (part.type === \"function\" &&\r\n                         part.name === args[i].slice(0, -2));\r\n            } else if (text === args[i].toLowerCase()) {\r\n                found = true;\r\n            }\r\n        }\r\n\r\n        return found;\r\n    },\r\n\r\n    isSimple: function(type) {\r\n        return Boolean(this.simple[type]);\r\n    },\r\n\r\n    isComplex: function(type) {\r\n        return Boolean(this.complex[type]);\r\n    },\r\n\r\n    describe: function(type) {\r\n        if (this.complex[type] instanceof Matcher) {\r\n            return this.complex[type].toString(0);\r\n        }\r\n        return type;\r\n    },\r\n\r\n    /**\r\n     * Determines if the next part(s) of the given expression\r\n     * are any of the given types.\r\n     */\r\n    isAny: function (expression, types) {\r\n        var args = types.split(\" | \"),\r\n            i, len, found = false;\r\n\r\n        for (i=0, len=args.length; i < len && !found && expression.hasNext(); i++) {\r\n            found = this.isType(expression, args[i]);\r\n        }\r\n\r\n        return found;\r\n    },\r\n\r\n    /**\r\n     * Determines if the next part(s) of the given expression\r\n     * are one of a group.\r\n     */\r\n    isAnyOfGroup: function(expression, types) {\r\n        var args = types.split(\" || \"),\r\n            i, len, found = false;\r\n\r\n        for (i=0, len=args.length; i < len && !found; i++) {\r\n            found = this.isType(expression, args[i]);\r\n        }\r\n\r\n        return found ? args[i-1] : false;\r\n    },\r\n\r\n    /**\r\n     * Determines if the next part(s) of the given expression\r\n     * are of a given type.\r\n     */\r\n    isType: function (expression, type) {\r\n        var part = expression.peek(),\r\n            result = false;\r\n\r\n        if (type.charAt(0) !== \"<\") {\r\n            result = this.isLiteral(part, type);\r\n            if (result) {\r\n                expression.next();\r\n            }\r\n        } else if (this.simple[type]) {\r\n            result = this.simple[type](part);\r\n            if (result) {\r\n                expression.next();\r\n            }\r\n        } else if (this.complex[type] instanceof Matcher) {\r\n            result = this.complex[type].match(expression);\r\n        } else {\r\n            result = this.complex[type](expression);\r\n        }\r\n\r\n        return result;\r\n    },\r\n\r\n\r\n    simple: {\r\n        __proto__: null,\r\n\r\n        \"<absolute-size>\":\r\n            \"xx-small | x-small | small | medium | large | x-large | xx-large\",\r\n\r\n        \"<animateable-feature>\":\r\n            \"scroll-position | contents | <animateable-feature-name>\",\r\n\r\n        \"<animateable-feature-name>\": function(part) {\r\n            return this[\"<ident>\"](part) &&\r\n                !/^(unset|initial|inherit|will-change|auto|scroll-position|contents)$/i.test(part);\r\n        },\r\n\r\n        \"<angle>\": function(part) {\r\n            return part.type === \"angle\";\r\n        },\r\n\r\n        \"<attachment>\": \"scroll | fixed | local\",\r\n\r\n        \"<attr>\": \"attr()\",\r\n\r\n        // inset() = inset( <shape-arg>{1,4} [round <border-radius>]? )\r\n        // circle() = circle( [<shape-radius>]? [at <position>]? )\r\n        // ellipse() = ellipse( [<shape-radius>{2}]? [at <position>]? )\r\n        // polygon() = polygon( [<fill-rule>,]? [<shape-arg> <shape-arg>]# )\r\n        \"<basic-shape>\": \"inset() | circle() | ellipse() | polygon()\",\r\n\r\n        \"<bg-image>\": \"<image> | <gradient> | none\",\r\n\r\n        \"<border-style>\":\r\n            \"none | hidden | dotted | dashed | solid | double | groove | \" +\r\n            \"ridge | inset | outset\",\r\n\r\n        \"<border-width>\": \"<length> | thin | medium | thick\",\r\n\r\n        \"<box>\": \"padding-box | border-box | content-box\",\r\n\r\n        \"<clip-source>\": \"<uri>\",\r\n\r\n        \"<color>\": function(part) {\r\n            return part.type === \"color\" || String(part) === \"transparent\" || String(part) === \"currentColor\";\r\n        },\r\n\r\n        // The SVG <color> spec doesn't include \"currentColor\" or \"transparent\" as a color.\r\n        \"<color-svg>\": function(part) {\r\n            return part.type === \"color\";\r\n        },\r\n\r\n        \"<content>\": \"content()\",\r\n\r\n        // https://www.w3.org/TR/css3-sizing/#width-height-keywords\r\n        \"<content-sizing>\":\r\n            \"fill-available | -moz-available | -webkit-fill-available | \" +\r\n            \"max-content | -moz-max-content | -webkit-max-content | \" +\r\n            \"min-content | -moz-min-content | -webkit-min-content | \" +\r\n            \"fit-content | -moz-fit-content | -webkit-fit-content\",\r\n\r\n        \"<feature-tag-value>\": function(part) {\r\n            return part.type === \"function\" && /^[A-Z0-9]{4}$/i.test(part);\r\n        },\r\n\r\n        // custom() isn't actually in the spec\r\n        \"<filter-function>\":\r\n            \"blur() | brightness() | contrast() | custom() | \" +\r\n            \"drop-shadow() | grayscale() | hue-rotate() | invert() | \" +\r\n            \"opacity() | saturate() | sepia()\",\r\n\r\n        \"<flex-basis>\": \"<width>\",\r\n\r\n        \"<flex-direction>\": \"row | row-reverse | column | column-reverse\",\r\n\r\n        \"<flex-grow>\": \"<number>\",\r\n\r\n        \"<flex-shrink>\": \"<number>\",\r\n\r\n        \"<flex-wrap>\": \"nowrap | wrap | wrap-reverse\",\r\n\r\n        \"<font-size>\":\r\n            \"<absolute-size> | <relative-size> | <length> | <percentage>\",\r\n\r\n        \"<font-stretch>\":\r\n            \"normal | ultra-condensed | extra-condensed | condensed | \" +\r\n            \"semi-condensed | semi-expanded | expanded | extra-expanded | \" +\r\n            \"ultra-expanded\",\r\n\r\n        \"<font-style>\": \"normal | italic | oblique\",\r\n\r\n        \"<font-variant-caps>\":\r\n            \"small-caps | all-small-caps | petite-caps | all-petite-caps | \" +\r\n            \"unicase | titling-caps\",\r\n\r\n        \"<font-variant-css21>\": \"normal | small-caps\",\r\n\r\n        \"<font-weight>\":\r\n            \"normal | bold | bolder | lighter | \" +\r\n            \"100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900\",\r\n\r\n        \"<generic-family>\":\r\n            \"serif | sans-serif | cursive | fantasy | monospace\",\r\n\r\n        \"<geometry-box>\": \"<shape-box> | fill-box | stroke-box | view-box\",\r\n\r\n        \"<glyph-angle>\": function(part) {\r\n            return part.type === \"angle\" && part.units === \"deg\";\r\n        },\r\n\r\n        \"<gradient>\": function(part) {\r\n            return part.type === \"function\" && /^(?:\\-(?:ms|moz|o|webkit)\\-)?(?:repeating\\-)?(?:radial\\-|linear\\-)?gradient/i.test(part);\r\n        },\r\n\r\n        \"<icccolor>\":\r\n            \"cielab() | cielch() | cielchab() | \" +\r\n            \"icc-color() | icc-named-color()\",\r\n\r\n        //any identifier\r\n        \"<ident>\": function(part) {\r\n            return part.type === \"identifier\" || part.wasIdent;\r\n        },\r\n\r\n        \"<ident-not-generic-family>\": function(part) {\r\n            return this[\"<ident>\"](part) && !this[\"<generic-family>\"](part);\r\n        },\r\n\r\n        \"<image>\": \"<uri>\",\r\n\r\n        \"<integer>\": function(part) {\r\n            return part.type === \"integer\";\r\n        },\r\n\r\n        \"<length>\": function(part) {\r\n            if (part.type === \"function\" && /^(?:\\-(?:ms|moz|o|webkit)\\-)?calc/i.test(part)) {\r\n                return true;\r\n            } else {\r\n                return part.type === \"length\" || part.type === \"number\" || part.type === \"integer\" || String(part) === \"0\";\r\n            }\r\n        },\r\n\r\n        \"<line>\": function(part) {\r\n            return part.type === \"integer\";\r\n        },\r\n\r\n        \"<line-height>\": \"<number> | <length> | <percentage> | normal\",\r\n\r\n        \"<margin-width>\": \"<length> | <percentage> | auto\",\r\n\r\n        \"<miterlimit>\": function(part) {\r\n            return this[\"<number>\"](part) && part.value >= 1;\r\n        },\r\n\r\n        \"<nonnegative-length-or-percentage>\": function(part) {\r\n            return (this[\"<length>\"](part) || this[\"<percentage>\"](part)) &&\r\n                (String(part) === \"0\" || part.type === \"function\" || (part.value) >= 0);\r\n        },\r\n\r\n        \"<nonnegative-number-or-percentage>\": function(part) {\r\n            return (this[\"<number>\"](part) || this[\"<percentage>\"](part)) &&\r\n                (String(part) === \"0\" || part.type === \"function\" || (part.value) >= 0);\r\n        },\r\n\r\n        \"<number>\": function(part) {\r\n            return part.type === \"number\" || this[\"<integer>\"](part);\r\n        },\r\n\r\n        \"<opacity-value>\": function(part) {\r\n            return this[\"<number>\"](part) && part.value >= 0 && part.value <= 1;\r\n        },\r\n\r\n        \"<padding-width>\": \"<nonnegative-length-or-percentage>\",\r\n\r\n        \"<percentage>\": function(part) {\r\n            return part.type === \"percentage\" || String(part) === \"0\";\r\n        },\r\n\r\n        \"<relative-size>\": \"smaller | larger\",\r\n\r\n        \"<shape>\": \"rect() | inset-rect()\",\r\n\r\n        \"<shape-box>\": \"<box> | margin-box\",\r\n\r\n        \"<single-animation-direction>\":\r\n            \"normal | reverse | alternate | alternate-reverse\",\r\n\r\n        \"<single-animation-name>\": function(part) {\r\n            return this[\"<ident>\"](part) &&\r\n                /^-?[a-z_][-a-z0-9_]+$/i.test(part) &&\r\n                !/^(none|unset|initial|inherit)$/i.test(part);\r\n        },\r\n\r\n        \"<string>\": function(part) {\r\n            return part.type === \"string\";\r\n        },\r\n\r\n        \"<time>\": function(part) {\r\n            return part.type === \"time\";\r\n        },\r\n\r\n        \"<uri>\": function(part) {\r\n            return part.type === \"uri\";\r\n        },\r\n\r\n        \"<width>\": \"<margin-width>\"\r\n    },\r\n\r\n    complex: {\r\n        __proto__: null,\r\n\r\n        \"<azimuth>\":\r\n            \"<angle>\" +\r\n            \" | \" +\r\n            \"[ [ left-side | far-left | left | center-left | center | \" +\r\n            \"center-right | right | far-right | right-side ] || behind ]\" +\r\n            \" | \"+\r\n            \"leftwards | rightwards\",\r\n\r\n        \"<bg-position>\": \"<position>#\",\r\n\r\n        \"<bg-size>\":\r\n            \"[ <length> | <percentage> | auto ]{1,2} | cover | contain\",\r\n\r\n        \"<border-image-slice>\":\r\n        // [<number> | <percentage>]{1,4} && fill?\r\n        // *but* fill can appear between any of the numbers\r\n        Matcher.many([true /* first element is required */],\r\n                     Matcher.cast(\"<nonnegative-number-or-percentage>\"),\r\n                     Matcher.cast(\"<nonnegative-number-or-percentage>\"),\r\n                     Matcher.cast(\"<nonnegative-number-or-percentage>\"),\r\n                     Matcher.cast(\"<nonnegative-number-or-percentage>\"),\r\n                     \"fill\"),\r\n\r\n        \"<border-radius>\":\r\n            \"<nonnegative-length-or-percentage>{1,4} \" +\r\n            \"[ / <nonnegative-length-or-percentage>{1,4} ]?\",\r\n\r\n        \"<box-shadow>\": \"none | <shadow>#\",\r\n\r\n        \"<clip-path>\": \"<basic-shape> || <geometry-box>\",\r\n\r\n        \"<dasharray>\":\r\n        // \"list of comma and/or white space separated <length>s and\r\n        // <percentage>s\".  There is a non-negative constraint.\r\n        Matcher.cast(\"<nonnegative-length-or-percentage>\")\r\n            .braces(1, Infinity, \"#\", Matcher.cast(\",\").question()),\r\n\r\n        \"<family-name>\":\r\n            // <string> | <IDENT>+\r\n            \"<string> | <ident-not-generic-family> <ident>*\",\r\n\r\n        \"<filter-function-list>\": \"[ <filter-function> | <uri> ]+\",\r\n\r\n        // https://www.w3.org/TR/2014/WD-css-flexbox-1-20140325/#flex-property\r\n        \"<flex>\":\r\n            \"none | [ <flex-grow> <flex-shrink>? || <flex-basis> ]\",\r\n\r\n        \"<font-family>\": \"[ <generic-family> | <family-name> ]#\",\r\n\r\n        \"<font-shorthand>\":\r\n            \"[ <font-style> || <font-variant-css21> || \" +\r\n            \"<font-weight> || <font-stretch> ]? <font-size> \" +\r\n            \"[ / <line-height> ]? <font-family>\",\r\n\r\n        \"<font-variant-alternates>\":\r\n            // stylistic(<feature-value-name>)\r\n            \"stylistic() || \" +\r\n            \"historical-forms || \" +\r\n            // styleset(<feature-value-name> #)\r\n            \"styleset() || \" +\r\n            // character-variant(<feature-value-name> #)\r\n            \"character-variant() || \" +\r\n            // swash(<feature-value-name>)\r\n            \"swash() || \" +\r\n            // ornaments(<feature-value-name>)\r\n            \"ornaments() || \" +\r\n            // annotation(<feature-value-name>)\r\n            \"annotation()\",\r\n\r\n        \"<font-variant-ligatures>\":\r\n            // <common-lig-values>\r\n            \"[ common-ligatures | no-common-ligatures ] || \" +\r\n            // <discretionary-lig-values>\r\n            \"[ discretionary-ligatures | no-discretionary-ligatures ] || \" +\r\n            // <historical-lig-values>\r\n            \"[ historical-ligatures | no-historical-ligatures ] || \" +\r\n            // <contextual-alt-values>\r\n            \"[ contextual | no-contextual ]\",\r\n\r\n        \"<font-variant-numeric>\":\r\n            // <numeric-figure-values>\r\n            \"[ lining-nums | oldstyle-nums ] || \" +\r\n            // <numeric-spacing-values>\r\n            \"[ proportional-nums | tabular-nums ] || \" +\r\n            // <numeric-fraction-values>\r\n            \"[ diagonal-fractions | stacked-fractions ] || \" +\r\n            \"ordinal || slashed-zero\",\r\n\r\n        \"<font-variant-east-asian>\":\r\n            // <east-asian-variant-values>\r\n            \"[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ] || \" +\r\n            // <east-asian-width-values>\r\n            \"[ full-width | proportional-width ] || \" +\r\n            \"ruby\",\r\n\r\n        // Note that <color> here is \"as defined in the SVG spec\", which\r\n        // is more restrictive that the <color> defined in the CSS spec.\r\n        // none | currentColor | <color> [<icccolor>]? |\r\n        // <funciri> [ none | currentColor | <color> [<icccolor>]? ]?\r\n        \"<paint>\": \"<paint-basic> | <uri> <paint-basic>?\",\r\n\r\n        // Helper definition for <paint> above.\r\n        \"<paint-basic>\": \"none | currentColor | <color-svg> <icccolor>?\",\r\n\r\n        \"<position>\":\r\n            // Because our `alt` combinator is ordered, we need to test these\r\n            // in order from longest possible match to shortest.\r\n            \"[ center | [ left | right ] [ <percentage> | <length> ]? ] && \" +\r\n            \"[ center | [ top | bottom ] [ <percentage> | <length> ]? ]\" +\r\n            \" | \" +\r\n            \"[ left | center | right | <percentage> | <length> ] \" +\r\n            \"[ top | center | bottom | <percentage> | <length> ]\" +\r\n            \" | \" +\r\n            \"[ left | center | right | top | bottom | <percentage> | <length> ]\",\r\n\r\n        \"<repeat-style>\":\r\n            \"repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}\",\r\n\r\n        \"<shadow>\":\r\n        //inset? && [ <length>{2,4} && <color>? ]\r\n        Matcher.many([true /* length is required */],\r\n                     Matcher.cast(\"<length>\").braces(2, 4), \"inset\", \"<color>\"),\r\n\r\n        \"<text-decoration-color>\":\r\n           \"<color>\",\r\n\r\n        \"<text-decoration-line>\":\r\n            \"none | [ underline || overline || line-through || blink ]\",\r\n\r\n        \"<text-decoration-style>\":\r\n            \"solid | double | dotted | dashed | wavy\",\r\n\r\n        \"<will-change>\":\r\n            \"auto | <animateable-feature>#\",\r\n\r\n        \"<x-one-radius>\":\r\n            //[ <length> | <percentage> ] [ <length> | <percentage> ]?\r\n            \"[ <length> | <percentage> ]{1,2}\"\r\n    }\r\n});\r\n\r\nObject.keys(ValidationTypes.simple).forEach(function(nt) {\r\n    var rule = ValidationTypes.simple[nt];\r\n    if (typeof rule === \"string\") {\r\n        ValidationTypes.simple[nt] = function(part) {\r\n            return ValidationTypes.isLiteral(part, rule);\r\n        };\r\n    }\r\n});\r\n\r\nObject.keys(ValidationTypes.complex).forEach(function(nt) {\r\n    var rule = ValidationTypes.complex[nt];\r\n    if (typeof rule === \"string\") {\r\n        ValidationTypes.complex[nt] = Matcher.parse(rule);\r\n    }\r\n});\r\n\r\n// Because this is defined relative to other complex validation types,\r\n// we need to define it *after* the rest of the types are initialized.\r\nValidationTypes.complex[\"<font-variant>\"] =\r\n    Matcher.oror({ expand: \"<font-variant-ligatures>\" },\r\n                 { expand: \"<font-variant-alternates>\" },\r\n                 \"<font-variant-caps>\",\r\n                 { expand: \"<font-variant-numeric>\" },\r\n                 { expand: \"<font-variant-east-asian>\" });\r\n","/home/travis/build/npmtest/node-npmtest-parserlib/node_modules/parserlib/src/css/ValidationError.js":"\"use strict\";\r\n\r\nmodule.exports = ValidationError;\r\n\r\n/**\r\n * Type to use when a validation error occurs.\r\n * @class ValidationError\r\n * @namespace parserlib.util\r\n * @constructor\r\n * @param {String} message The error message.\r\n * @param {int} line The line at which the error occurred.\r\n * @param {int} col The column at which the error occurred.\r\n */\r\nfunction ValidationError(message, line, col) {\r\n\r\n    /**\r\n     * The column at which the error occurred.\r\n     * @type int\r\n     * @property col\r\n     */\r\n    this.col = col;\r\n\r\n    /**\r\n     * The line at which the error occurred.\r\n     * @type int\r\n     * @property line\r\n     */\r\n    this.line = line;\r\n\r\n    /**\r\n     * The text representation of the unit.\r\n     * @type String\r\n     * @property text\r\n     */\r\n    this.message = message;\r\n\r\n}\r\n\r\n//inherit from Error\r\nValidationError.prototype = new Error();\r\n","/home/travis/build/npmtest/node-npmtest-parserlib/node_modules/parserlib/src/css/PropertyValueIterator.js":"\"use strict\";\r\n\r\nmodule.exports = PropertyValueIterator;\r\n\r\n/**\r\n * A utility class that allows for easy iteration over the various parts of a\r\n * property value.\r\n * @param {parserlib.css.PropertyValue} value The property value to iterate over.\r\n * @namespace parserlib.css\r\n * @class PropertyValueIterator\r\n * @constructor\r\n */\r\nfunction PropertyValueIterator(value) {\r\n\r\n    /**\r\n     * Iterator value\r\n     * @type int\r\n     * @property _i\r\n     * @private\r\n     */\r\n    this._i = 0;\r\n\r\n    /**\r\n     * The parts that make up the value.\r\n     * @type Array\r\n     * @property _parts\r\n     * @private\r\n     */\r\n    this._parts = value.parts;\r\n\r\n    /**\r\n     * Keeps track of bookmarks along the way.\r\n     * @type Array\r\n     * @property _marks\r\n     * @private\r\n     */\r\n    this._marks = [];\r\n\r\n    /**\r\n     * Holds the original property value.\r\n     * @type parserlib.css.PropertyValue\r\n     * @property value\r\n     */\r\n    this.value = value;\r\n\r\n}\r\n\r\n/**\r\n * Returns the total number of parts in the value.\r\n * @return {int} The total number of parts in the value.\r\n * @method count\r\n */\r\nPropertyValueIterator.prototype.count = function() {\r\n    return this._parts.length;\r\n};\r\n\r\n/**\r\n * Indicates if the iterator is positioned at the first item.\r\n * @return {Boolean} True if positioned at first item, false if not.\r\n * @method isFirst\r\n */\r\nPropertyValueIterator.prototype.isFirst = function() {\r\n    return this._i === 0;\r\n};\r\n\r\n/**\r\n * Indicates if there are more parts of the property value.\r\n * @return {Boolean} True if there are more parts, false if not.\r\n * @method hasNext\r\n */\r\nPropertyValueIterator.prototype.hasNext = function() {\r\n    return this._i < this._parts.length;\r\n};\r\n\r\n/**\r\n * Marks the current spot in the iteration so it can be restored to\r\n * later on.\r\n * @return {void}\r\n * @method mark\r\n */\r\nPropertyValueIterator.prototype.mark = function() {\r\n    this._marks.push(this._i);\r\n};\r\n\r\n/**\r\n * Returns the next part of the property value or null if there is no next\r\n * part. Does not move the internal counter forward.\r\n * @return {parserlib.css.PropertyValuePart} The next part of the property value or null if there is no next\r\n * part.\r\n * @method peek\r\n */\r\nPropertyValueIterator.prototype.peek = function(count) {\r\n    return this.hasNext() ? this._parts[this._i + (count || 0)] : null;\r\n};\r\n\r\n/**\r\n * Returns the next part of the property value or null if there is no next\r\n * part.\r\n * @return {parserlib.css.PropertyValuePart} The next part of the property value or null if there is no next\r\n * part.\r\n * @method next\r\n */\r\nPropertyValueIterator.prototype.next = function() {\r\n    return this.hasNext() ? this._parts[this._i++] : null;\r\n};\r\n\r\n/**\r\n * Returns the previous part of the property value or null if there is no\r\n * previous part.\r\n * @return {parserlib.css.PropertyValuePart} The previous part of the\r\n * property value or null if there is no previous part.\r\n * @method previous\r\n */\r\nPropertyValueIterator.prototype.previous = function() {\r\n    return this._i > 0 ? this._parts[--this._i] : null;\r\n};\r\n\r\n/**\r\n * Restores the last saved bookmark.\r\n * @return {void}\r\n * @method restore\r\n */\r\nPropertyValueIterator.prototype.restore = function() {\r\n    if (this._marks.length) {\r\n        this._i = this._marks.pop();\r\n    }\r\n};\r\n\r\n/**\r\n * Drops the last saved bookmark.\r\n * @return {void}\r\n * @method drop\r\n */\r\nPropertyValueIterator.prototype.drop = function() {\r\n    this._marks.pop();\r\n};\r\n","/home/travis/build/npmtest/node-npmtest-parserlib/node_modules/parserlib/src/util/index.js":"\"use strict\";\r\n\r\nmodule.exports = {\r\n    StringReader    : require(\"./StringReader\"),\r\n    SyntaxError     : require(\"./SyntaxError\"),\r\n    SyntaxUnit      : require(\"./SyntaxUnit\"),\r\n    EventTarget     : require(\"./EventTarget\"),\r\n    TokenStreamBase : require(\"./TokenStreamBase\")\r\n};\r\n"}